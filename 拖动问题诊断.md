# 便签拖动不跟手问题诊断

## 🔍 问题描述

便签拖动时不跟手，可能是坐标转换问题。

---

## 🧪 诊断步骤

### 1️⃣ 打开浏览器控制台

按 `F12` 或 `Cmd+Option+I` (Mac)

---

### 2️⃣ 检查当前画布状态

在控制台执行：

```javascript
// 获取画布状态
const canvasStore = window.useCanvasStore.getState();
const noteStore = window.useNoteStore.getState();

console.log("=== 画布状态诊断 ===");
console.log("视口偏移 (offset):", canvasStore.viewport.offset);
console.log("视口缩放 (scale):", canvasStore.viewport.scale);
console.log("便签数量:", noteStore.notes.length);

// 如果有便签，检查第一个便签
if (noteStore.notes.length > 0) {
  const firstNote = noteStore.notes[0];
  console.log("第一个便签位置:", firstNote.position);
  console.log("第一个便签尺寸:", firstNote.size);
}
```

**预期结果：**

- `offset` 应该接近 `{x: 960, y: 540}` (屏幕尺寸的一半)
- `scale` 应该是 `1`
- 便签位置应该接近 `(0, 0)` 附近

---

### 3️⃣ 测试拖动便签

1. 拖动一个便签
2. 在控制台执行：

```javascript
// 检查便签拖动后的位置
const noteStore = window.useNoteStore.getState();
const notes = noteStore.notes;

notes.forEach((note, index) => {
  console.log(`便签 ${index + 1}:`, {
    id: note.id.slice(-8),
    position: note.position,
    size: note.size,
  });
});
```

---

### 4️⃣ 检查拖动计算是否正确

创建测试便签并观察：

```javascript
// 测试：在画布中心创建便签
async function testNoteCreation() {
  const canvasStore = window.useCanvasStore.getState();
  const noteStore = window.useNoteStore.getState();

  const viewport = canvasStore.viewport;
  const activeCanvasId = canvasStore.activeCanvasId;

  console.log("当前视口:", viewport);

  // 计算屏幕中心对应的画布坐标
  const screenCenterX = window.innerWidth / 2;
  const screenCenterY = window.innerHeight / 2;

  const canvasCenterX = (screenCenterX - viewport.offset.x) / viewport.scale;
  const canvasCenterY = (screenCenterY - viewport.offset.y) / viewport.scale;

  console.log("屏幕中心对应的画布坐标:", {
    x: canvasCenterX,
    y: canvasCenterY,
  });
  console.log("理论上应该接近 (0, 0)");

  // 创建便签
  if (activeCanvasId) {
    await noteStore.createNote(activeCanvasId, {
      x: canvasCenterX - 135, // 居中（便签宽度 270 / 2）
      y: canvasCenterY - 120, // 居中（便签高度 240 / 2）
    });
    console.log("✅ 测试便签已创建");
  }
}

// 执行测试
testNoteCreation();
```

---

## 🐛 常见问题和解决方案

### 问题 1：便签拖动时"跳跃"

**原因：** 坐标转换时没有考虑缩放比例

**检查代码：**

```typescript
// Canvas/index.tsx 的 handleDragEnd
const newPosition = {
  x: note.position.x + delta.x / viewport.scale, // ← 必须除以 scale
  y: note.position.y + delta.y / viewport.scale,
};
```

**如果没有除以 scale，就会出现跳跃！**

---

### 问题 2：便签位置偏移

**原因：** offset 计算错误

**验证：**

```javascript
// 在控制台执行
const offset = window.useCanvasStore.getState().viewport.offset;
const expected = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
};

console.log("当前 offset:", offset);
console.log("预期 offset:", expected);
console.log("差异:", {
  x: Math.abs(offset.x - expected.x),
  y: Math.abs(offset.y - expected.y),
});

// 如果差异很大（超过100px），说明有问题
```

---

### 问题 3：拖动延迟或卡顿

**原因：** 性能问题或防抖设置不当

**检查：**

```javascript
// 查看便签更新是否被防抖
const saveNoteTimeouts = window.saveNoteTimeouts || new Map();
console.log("当前防抖定时器数量:", saveNoteTimeouts.size);

// 如果数量很多（>10），可能是内存泄漏
```

---

### 问题 4：拖动时便签消失

**原因：** zIndex 或 transform 设置问题

**检查 DOM：**

```javascript
// 获取所有便签元素
const noteCards = document.querySelectorAll('[class*="noteCard"]');
console.log("DOM 中的便签数量:", noteCards.length);

noteCards.forEach((card, i) => {
  const style = window.getComputedStyle(card);
  console.log(`便签 ${i + 1}:`, {
    position: style.position,
    left: style.left,
    top: style.top,
    transform: style.transform,
    zIndex: style.zIndex,
    display: style.display,
    visibility: style.visibility,
  });
});
```

---

## 🎯 快速诊断脚本（一键运行）

在控制台直接复制粘贴运行：

```javascript
(function diagnose() {
  console.clear();
  console.log("🔍 开始诊断便签拖动问题...\n");

  // 1. 检查 Store 是否存在
  if (!window.useCanvasStore || !window.useNoteStore) {
    console.error("❌ Store 未挂载到 window 对象");
    console.log("请在 src/store/canvasStore.ts 添加:");
    console.log('if (typeof window !== "undefined") {');
    console.log("  (window as any).useCanvasStore = useCanvasStore;");
    console.log("}");
    return;
  }

  const canvasStore = window.useCanvasStore.getState();
  const noteStore = window.useNoteStore.getState();

  // 2. 检查画布状态
  console.log("📐 画布状态:");
  console.log("  缩放比例:", canvasStore.viewport.scale);
  console.log("  偏移量:", canvasStore.viewport.offset);
  console.log("  屏幕尺寸:", window.innerWidth, "x", window.innerHeight);

  const expectedOffset = {
    x: window.innerWidth / 2,
    y: window.innerHeight / 2,
  };
  const offsetDiff = {
    x: Math.abs(canvasStore.viewport.offset.x - expectedOffset.x),
    y: Math.abs(canvasStore.viewport.offset.y - expectedOffset.y),
  };

  console.log("  预期偏移:", expectedOffset);
  console.log("  偏移差异:", offsetDiff);

  if (offsetDiff.x > 100 || offsetDiff.y > 100) {
    console.warn("⚠️ offset 可能不正确！差异超过 100px");
  } else {
    console.log("✅ offset 正常");
  }

  // 3. 检查便签
  console.log("\n📝 便签状态:");
  console.log("  便签数量:", noteStore.notes.length);

  if (noteStore.notes.length === 0) {
    console.log("  ℹ️ 没有便签，创建一个测试便签吧！");
  } else {
    noteStore.notes.slice(0, 3).forEach((note, i) => {
      console.log(`  便签 ${i + 1}:`, {
        id: note.id.slice(-8),
        position: note.position,
        size: note.size,
        zIndex: note.zIndex,
      });
    });
  }

  // 4. 检查 DOM
  const noteCards = document.querySelectorAll('[class*="noteCard"]');
  console.log("\n🖼️ DOM 状态:");
  console.log("  DOM 中的便签数量:", noteCards.length);

  if (noteCards.length !== noteStore.notes.length) {
    console.warn("⚠️ Store 和 DOM 中的便签数量不一致！");
  } else {
    console.log("✅ 便签数量一致");
  }

  // 5. 检查 canvasContent 的 transform
  const canvasContent = document.querySelector('[class*="canvasContent"]');
  if (canvasContent) {
    const transform = window.getComputedStyle(canvasContent).transform;
    console.log("\n🎨 canvasContent transform:");
    console.log("  ", transform);

    // 解析 transform
    const matches = transform.match(
      /matrix\(([-\d.]+),\s*([-\d.]+),\s*([-\d.]+),\s*([-\d.]+),\s*([-\d.]+),\s*([-\d.]+)\)/
    );
    if (matches) {
      const translateX = parseFloat(matches[5]);
      const translateY = parseFloat(matches[6]);
      const scaleX = parseFloat(matches[1]);

      console.log("  解析结果:");
      console.log("    translateX:", translateX);
      console.log("    translateY:", translateY);
      console.log("    scale:", scaleX);

      if (
        Math.abs(translateX - canvasStore.viewport.offset.x) > 1 ||
        Math.abs(translateY - canvasStore.viewport.offset.y) > 1
      ) {
        console.warn("⚠️ DOM transform 和 Store 状态不一致！");
      } else {
        console.log("✅ transform 正常");
      }
    }
  }

  // 6. 测试坐标转换
  console.log("\n🧮 坐标转换测试:");
  const screenCenterX = window.innerWidth / 2;
  const screenCenterY = window.innerHeight / 2;
  const canvasCenterX =
    (screenCenterX - canvasStore.viewport.offset.x) /
    canvasStore.viewport.scale;
  const canvasCenterY =
    (screenCenterY - canvasStore.viewport.offset.y) /
    canvasStore.viewport.scale;

  console.log("  屏幕中心:", screenCenterX, screenCenterY);
  console.log(
    "  对应画布坐标:",
    canvasCenterX.toFixed(2),
    canvasCenterY.toFixed(2)
  );
  console.log("  理论应该接近: (0, 0)");

  if (Math.abs(canvasCenterX) > 10 || Math.abs(canvasCenterY) > 10) {
    console.warn("⚠️ 坐标转换可能有问题！屏幕中心不在画布 (0,0) 附近");
  } else {
    console.log("✅ 坐标转换正常");
  }

  // 7. 总结
  console.log("\n📊 诊断完成！");
  console.log("─────────────────────────────");

  const issues = [];
  if (offsetDiff.x > 100 || offsetDiff.y > 100) issues.push("offset 偏移");
  if (noteCards.length !== noteStore.notes.length) issues.push("DOM 不一致");
  if (Math.abs(canvasCenterX) > 10 || Math.abs(canvasCenterY) > 10)
    issues.push("坐标转换");

  if (issues.length === 0) {
    console.log("✅ 未发现明显问题");
    console.log("如果仍然拖动不跟手，请检查:");
    console.log("  1. 是否在缩放状态下拖动（scale !== 1）");
    console.log("  2. 拖动时是否触发了其他事件（如文本选择）");
    console.log("  3. 浏览器性能（打开性能监视器）");
  } else {
    console.error("❌ 发现问题:", issues.join(", "));
  }
})();
```

---

## 🔧 修复建议

根据诊断结果，可能需要修复的地方：

### 修复 1：确保 Store 暴露到 window（便于调试）

在 `src/store/canvasStore.ts` 文件末尾添加：

```typescript
// 开发环境下暴露到 window（便于调试）
if (typeof window !== "undefined" && process.env.NODE_ENV === "development") {
  (window as any).useCanvasStore = useCanvasStore;
}
```

在 `src/store/noteStore.ts` 文件末尾添加：

```typescript
// 开发环境下暴露到 window（便于调试）
if (typeof window !== "undefined" && process.env.NODE_ENV === "development") {
  (window as any).useNoteStore = useNoteStore;
}
```

### 修复 2：检查 handleDragEnd 是否正确

确保 `src/pages/Canvas/index.tsx` 的 `handleDragEnd` 有除以 scale：

```typescript
const handleDragEnd = useCallback(
  (event: DragEndEvent) => {
    const { active, delta } = event;
    const note = active.data.current?.note as Note;

    if (note && delta) {
      const newPosition = {
        x: note.position.x + delta.x / viewport.scale, // ← 关键！
        y: note.position.y + delta.y / viewport.scale,
      };

      moveNote(note.id, newPosition);
    }

    endDrag();
  },
  [moveNote, endDrag, viewport.scale]
);
```

---

## 📞 下一步

1. 运行诊断脚本
2. 把控制台输出的结果发给我
3. 我会根据结果告诉你具体修复方案

或者直接告诉我：

- 拖动时的具体表现（跳跃？延迟？位置错误？）
- 是否在缩放状态下拖动（scale 不等于 1）
- 是否所有便签都有问题，还是只有特定便签
