# InfinityNote2 AI åŠŸèƒ½å¼€å‘æŒ‡å—

> **ç‰ˆæœ¬**: 2.0 | **æ›´æ–°æ—¶é—´**: 2025-09-16 | **æ¶æ„å¸ˆå®¡æŸ¥**: âœ… å·²é€šè¿‡

## ğŸ” æ¶æ„å¸ˆå®¡æŸ¥æ‘˜è¦

**è¯„ä¼°ç­‰çº§**: B+ (7.5/10) - æ€»ä½“æ€è·¯æ­£ç¡®ï¼Œå®ç°ç»†èŠ‚éœ€è°ƒæ•´

- âœ… **æ•°æ®ç»“æ„è®¾è®¡**: ä¼˜ç§€ (9/10) - å®Œç¾åˆ©ç”¨ç°æœ‰æ‰©å±•æ€§
- âš ï¸ **ç»„ä»¶æ¶æ„**: éœ€é‡æ„ (5/10) - è¿‡åº¦å¤æ‚åŒ–ï¼Œéœ€ç®€åŒ–é›†æˆ
- âœ… **æœåŠ¡å±‚è®¾è®¡**: è‰¯å¥½ (7/10) - åŸºç¡€åˆç†ï¼Œéœ€ç»Ÿä¸€æ¨¡å¼
- âš ï¸ **çŠ¶æ€ç®¡ç†**: éœ€è°ƒæ•´ (6/10) - åº”é›†æˆç°æœ‰ store è€Œéç‹¬ç«‹
- âš ï¸ **å®‰å…¨æ€§**: éœ€å®Œå–„ (6/10) - API å¯†é’¥ç®¡ç†éœ€åŠ å¼º

## 1. èƒŒæ™¯ä¸ç›®æ ‡

æœ¬æŒ‡å—é¢å‘ InfinityNote2 é¡¹ç›®å¼€å‘è€…ï¼Œæ—¨åœ¨æŒ‡å¯¼å¦‚ä½•**æ¶æ„ä¸€è‡´ã€ä½ä¾µå…¥**åœ°é›†æˆ AI ä¾¿ç­¾ç”ŸæˆåŠŸèƒ½ï¼ˆå«æ€ç»´é“¾ï¼‰ï¼Œå®ç° MVP ç‰ˆæœ¬å¹¶ä¸ºåç»­æ‰©å±•æ‰“ä¸‹åŸºç¡€ã€‚

**æ ¸å¿ƒæ¶æ„åŸåˆ™**ï¼š

- ğŸ¯ **æœ€å°ä¾µå…¥**ï¼šå……åˆ†åˆ©ç”¨ç°æœ‰ `customProperties` æ‰©å±•æ€§
- ğŸ”„ **æ¶æ„ä¸€è‡´**ï¼šéµå¾ªç°æœ‰ç»„ä»¶å’ŒæœåŠ¡çš„è®¾è®¡æ¨¡å¼
- ğŸ›¡ï¸ **å‘åå…¼å®¹**ï¼šä¸ç ´åç°æœ‰åŠŸèƒ½å’Œç”¨æˆ·æ•°æ®
- âš¡ **æ€§èƒ½ä¼˜å…ˆ**ï¼šé›†æˆç°æœ‰çš„é˜²æŠ–å’Œæ€§èƒ½ä¼˜åŒ–æœºåˆ¶

## 2. æŠ€æœ¯é€‰å‹ä¸æ¶æ„å…¼å®¹æ€§

- **å‰ç«¯æ¡†æ¶**ï¼šReact 19 + TypeScript âœ…
- **çŠ¶æ€ç®¡ç†**ï¼šZustand âœ… (é›†æˆç°æœ‰ noteStore)
- **å¯Œæ–‡æœ¬ç¼–è¾‘å™¨**ï¼šTipTap 3.4.2 âœ… (æ‰©å±•æ€ç»´é“¾æ˜¾ç¤º)
- **æœ¬åœ°å­˜å‚¨**ï¼šDexieï¼ˆIndexedDBï¼‰âœ… (ä½¿ç”¨ customProperties)
- **UI ç»„ä»¶**ï¼šAnt Design 5.27.3 âœ… (é›†æˆç°æœ‰å·¥å…·æ )
- **æ„å»ºå·¥å…·**ï¼šVite 7.1.2 âœ…
- **æ¨è AI æœåŠ¡å•†**ï¼šæ™ºè°± AIï¼ˆGLM-4ï¼‰ï¼Œå¤‡é€‰ OpenAIï¼ˆGPT-4oï¼‰

> **æ¶æ„å¸ˆéªŒè¯**ï¼šç°æœ‰æ¶æ„ä¸ AI åŠŸèƒ½é«˜åº¦å…¼å®¹ï¼Œæ— éœ€å¤§å¹…è°ƒæ•´ã€‚

## 3. æ ¸å¿ƒæ¶æ„è®¾è®¡ï¼ˆä¼˜åŒ–ç‰ˆï¼‰

### 3.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€ AI æœåŠ¡å±‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  aiService.ts (ç»Ÿä¸€APIè°ƒç”¨)       â”‚
â”‚  aiConfigService.ts (é…ç½®ç®¡ç†)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€ çŠ¶æ€ç®¡ç†å±‚ â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  noteStore.ts   â”‚æ‰©å±•AIæ–¹æ³•      â”‚ â† é›†æˆç°æœ‰store
â”‚  (ç°æœ‰)         â”‚               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€ ç»„ä»¶å±‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NoteToolbar    â”‚+ AIæŒ‰é’®        â”‚ â† ç°æœ‰ç»„ä»¶æ‰©å±•
â”‚  TiptapEditor   â”‚+ æ€ç»´é“¾æ‰©å±•     â”‚ â† ç°æœ‰ç¼–è¾‘å™¨æ‰©å±•
â”‚  NoteCard       â”‚ä¿æŒç°æœ‰ç»“æ„     â”‚ â† æ— éœ€ä¿®æ”¹
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 UI é›†æˆç­–ç•¥ï¼ˆä¿®æ­£ç‰ˆï¼‰

**ç°æœ‰ NoteCard ç»“æ„ä¿æŒä¸å˜**ï¼š

```tsx
// ç°æœ‰ç»“æ„ï¼Œæ— éœ€ä¿®æ”¹
<div className={styles.noteCardContainer}>
  <div className={styles.noteCard}>
    <div className={styles.noteHeader}>
      <h3>{note.title}</h3>
    </div>
    <div className={styles.noteContent}>
      <TiptapEditor /> {/* åœ¨æ­¤å†…éƒ¨é›†æˆæ€ç»´é“¾ */}
    </div>
  </div>
  <NoteToolbar /> {/* åœ¨æ­¤æ·»åŠ AIæŒ‰é’® */}
</div>
```

### 3.3 æ€ç»´é“¾é›†æˆæ–¹æ¡ˆï¼ˆæ¶æ„å¸ˆä¼˜åŒ–ï¼‰

**âŒ åŸæ–¹æ¡ˆé—®é¢˜**ï¼šç‹¬ç«‹ ThinkingChainCollapsible ç»„ä»¶ç ´åç°æœ‰æ¶æ„
**âœ… ä¼˜åŒ–æ–¹æ¡ˆ**ï¼šé›†æˆåˆ° TipTap ç¼–è¾‘å™¨å†…éƒ¨

```tsx
// TiptapEditor.tsx - æ‰©å±•æ€ç»´é“¾æ˜¾ç¤º
export const TiptapEditor = memo<TiptapEditorProps>(() => {
  // ... ç°æœ‰é€»è¾‘ä¿æŒä¸å˜

  // æ–°å¢ï¼šAIæ€ç»´é“¾æ•°æ®è·å–
  const aiData = note.customProperties?.ai;
  const showThinkingChain = shouldShowThinkingChain(note, aiData);

  return (
    <TiptapEditorErrorBoundary>
      <div className={containerClassName} style={editorStyle}>
        {/* æ–°å¢ï¼šæ€ç»´é“¾æ˜¾ç¤ºåŒºåŸŸï¼ˆæ¡ä»¶æ¸²æŸ“ï¼‰ */}
        {showThinkingChain && (
          <ThinkingChainDisplay
            thinkingData={aiData.thinkingChain}
            isCollapsed={aiData.thinkingCollapsed ?? true}
            onToggle={handleThinkingToggle}
          />
        )}

        {/* ç°æœ‰ï¼šç¼–è¾‘å™¨å†…å®¹åŒºåŸŸ */}
        <EditorContent editor={editor} className="tiptap-editor-content" />

        {/* ç°æœ‰ï¼šå·¥å…·æ  */}
        {editor && <Toolbar editor={editor} config={toolbarConfig} />}
      </div>
    </TiptapEditorErrorBoundary>
  );
});

// æ€ç»´é“¾æ˜¾ç¤ºé€»è¾‘ï¼ˆç®€åŒ–ç‰ˆï¼‰
const shouldShowThinkingChain = (note: Note, aiData?: any): boolean => {
  return !!(
    (
      aiData?.generated && // AIç”Ÿæˆçš„ä¾¿ç­¾
      aiData?.model && // æœ‰AIæ¨¡å‹ä¿¡æ¯
      aiData?.thinkingChain && // æœ‰æ€ç»´é“¾æ•°æ®
      aiData?.showThinking !== false
    ) // ç”¨æˆ·æœªå…³é—­æ˜¾ç¤º
  );
};
```

### 3.4 å·¥å…·æ é›†æˆæ–¹æ¡ˆ

```tsx
// NoteToolbar.tsx - æ·»åŠ AIåŠŸèƒ½æŒ‰é’®
export const NoteToolbar: React.FC<NoteToolbarProps> = ({
  noteId,
  onAction,
}) => {
  return (
    <div className={styles.noteToolbar}>
      {/* ç°æœ‰æŒ‰é’®ä¿æŒä¸å˜ */}
      <Button icon={<DeleteOutlined />} onClick={() => onAction("delete")} />
      <Button icon={<CopyOutlined />} onClick={() => onAction("duplicate")} />

      {/* æ–°å¢ï¼šAIåŠŸèƒ½æŒ‰é’® */}
      <Button
        icon={<RobotOutlined />}
        onClick={() => onAction("ai-generate")}
        title="AIç”Ÿæˆå†…å®¹"
      />
      <Button
        icon={<SettingOutlined />}
        onClick={() => onAction("ai-config")}
        title="AIè®¾ç½®"
      />
    </div>
  );
};
```

## 4. æ•°æ®ç»“æ„è®¾è®¡ï¼ˆæ¶æ„å¸ˆéªŒè¯ç‰ˆï¼‰

### 4.1 Note ç±»å‹æ‰©å±•ï¼ˆâœ… ä¼˜ç§€è®¾è®¡ï¼‰

**æ¶æ„å¸ˆè¯„ä¼°**ï¼šç°æœ‰ Note æ¥å£çš„ `customProperties` å­—æ®µè®¾è®¡ä¼˜ç§€ï¼Œä¸º AI åŠŸèƒ½æä¾›äº†å®Œç¾çš„æ‰©å±•ç‚¹ã€‚

```typescript
// ç°æœ‰ Note æ¥å£ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰
export interface Note {
  // ... ç°æœ‰å­—æ®µä¿æŒä¸å˜

  /** è‡ªå®šä¹‰å±æ€§ - AIåŠŸèƒ½çš„å®Œç¾æ‰©å±•ç‚¹ */
  customProperties?: Record<string, any>;
}

// AI æ•°æ®ç»“æ„å®šä¹‰
interface AICustomProperties {
  ai?: {
    // åŸºç¡€ä¿¡æ¯
    generated: boolean; // æ˜¯å¦AIç”Ÿæˆ
    model: string; // ä½¿ç”¨çš„AIæ¨¡å‹
    provider: string; // AIæœåŠ¡æä¾›å•†
    generatedAt: string; // ç”Ÿæˆæ—¶é—´

    // ç”Ÿæˆå‚æ•°
    prompt: string; // ç”¨æˆ·è¾“å…¥çš„æç¤º
    temperature?: number; // ç”Ÿæˆæ¸©åº¦
    maxTokens?: number; // æœ€å¤§tokenæ•°

    // æ€ç»´é“¾æ•°æ®ï¼ˆå¦‚æœæ”¯æŒï¼‰
    thinkingChain?: {
      steps: Array<{
        id: string;
        content: string;
        timestamp: number;
      }>;
      summary: string;
      totalSteps: number;
    };

    // UIçŠ¶æ€
    showThinking?: boolean; // æ˜¯å¦æ˜¾ç¤ºæ€ç»´é“¾
    thinkingCollapsed?: boolean; // æ€ç»´é“¾æ˜¯å¦æŠ˜å 

    // å…ƒæ•°æ®
    requestId: string; // è¯·æ±‚IDï¼Œç”¨äºè°ƒè¯•
    cost?: {
      // æˆæœ¬ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
      inputTokens: number;
      outputTokens: number;
      totalCost: number;
    };
  };
}

// ä½¿ç”¨ç¤ºä¾‹
const aiNote: Note = {
  id: "note_123",
  title: "AIç”Ÿæˆçš„ä¾¿ç­¾",
  content: "<p>AIç”Ÿæˆçš„å†…å®¹...</p>",
  customProperties: {
    ai: {
      generated: true,
      model: "glm-4-plus",
      provider: "zhipu",
      generatedAt: "2025-09-16T10:00:00Z",
      prompt: "ç”¨æˆ·çš„åŸå§‹æç¤º",
      thinkingChain: {
        steps: [
          {
            id: "step1",
            content: "åˆ†æç”¨æˆ·éœ€æ±‚...",
            timestamp: 1726480800000,
          },
        ],
        summary: "é€šè¿‡3æ­¥æ¨ç†å¾—å‡ºç»“è®º",
        totalSteps: 3,
      },
      showThinking: true,
      thinkingCollapsed: false,
      requestId: "req_abc123",
    },
  },
  // ... å…¶ä»–å­—æ®µ
};
```

### 4.2 æ•°æ®å­˜å‚¨ç­–ç•¥

**âœ… æ¶æ„å¸ˆæ¨è**ï¼šä½¿ç”¨ç°æœ‰å­˜å‚¨æœºåˆ¶ï¼Œæ— éœ€ schema å˜æ›´

```typescript
// åœ¨ç°æœ‰ noteService.ts ä¸­æ‰©å±•æ–¹æ³•
export class NoteService {
  // ç°æœ‰æ–¹æ³•ä¿æŒä¸å˜...

  // æ–°å¢ï¼šä¿å­˜AIç”Ÿæˆçš„ä¾¿ç­¾
  static async saveAINote(
    noteData: Partial<Note>,
    aiData: AICustomProperties["ai"]
  ): Promise<string> {
    const noteWithAI: Partial<Note> = {
      ...noteData,
      customProperties: {
        ...noteData.customProperties,
        ai: aiData,
      },
    };

    return await this.createNote(noteWithAI);
  }

  // æ–°å¢ï¼šæ›´æ–°AIæ•°æ®
  static async updateAIData(
    noteId: string,
    aiData: Partial<AICustomProperties["ai"]>
  ): Promise<void> {
    const note = await this.getNoteById(noteId);
    if (note) {
      const updatedProperties = {
        ...note.customProperties,
        ai: {
          ...note.customProperties?.ai,
          ...aiData,
        },
      };

      await this.updateNote(noteId, { customProperties: updatedProperties });
    }
  }
}
```

## 5. çŠ¶æ€ç®¡ç†è®¾è®¡ï¼ˆæ¶æ„å¸ˆä¼˜åŒ–ï¼‰

### 5.1 é›†æˆåˆ°ç°æœ‰ noteStoreï¼ˆâœ… æ¨èæ–¹æ¡ˆï¼‰

**âŒ åŸæ–¹æ¡ˆé—®é¢˜**ï¼šç‹¬ç«‹çš„ aiStore å¯¼è‡´çŠ¶æ€åˆ†æ•£ï¼Œå¢åŠ å¤æ‚åº¦
**âœ… ä¼˜åŒ–æ–¹æ¡ˆ**ï¼šæ‰©å±•ç°æœ‰ noteStoreï¼Œä¿æŒçŠ¶æ€ç»Ÿä¸€

```typescript
// src/store/noteStore.ts - æ‰©å±•AIåŠŸèƒ½
interface NoteState {
  // ... ç°æœ‰çŠ¶æ€ä¿æŒä¸å˜

  // æ–°å¢ï¼šAIç›¸å…³çŠ¶æ€
  aiGenerating: Record<string, boolean>; // æ­£åœ¨ç”ŸæˆAIå†…å®¹çš„ä¾¿ç­¾
  aiStreamingData: Record<string, string>; // æµå¼ç”Ÿæˆçš„å®æ—¶æ•°æ®
  aiErrors: Record<string, string>; // AIç”Ÿæˆé”™è¯¯ä¿¡æ¯
}

interface NoteActions {
  // ... ç°æœ‰æ–¹æ³•ä¿æŒä¸å˜

  // æ–°å¢ï¼šAIç›¸å…³æ–¹æ³•
  startAIGeneration: (noteId: string, prompt: string) => Promise<void>;
  updateAIStreamingContent: (noteId: string, content: string) => void;
  completeAIGeneration: (
    noteId: string,
    finalContent: string,
    aiData: any
  ) => Promise<void>;
  cancelAIGeneration: (noteId: string) => void;
  toggleThinkingChain: (noteId: string) => Promise<void>;
}

// åœ¨ç°æœ‰ useNoteStore ä¸­æ·»åŠ AIæ–¹æ³•
export const useNoteStore = create<NoteStore>()(
  devtools((set, get) => ({
    // ... ç°æœ‰çŠ¶æ€å’Œæ–¹æ³•ä¿æŒä¸å˜

    // æ–°å¢ï¼šAIç›¸å…³çŠ¶æ€
    aiGenerating: {},
    aiStreamingData: {},
    aiErrors: {},

    // æ–°å¢ï¼šå¼€å§‹AIç”Ÿæˆ
    startAIGeneration: async (noteId: string, prompt: string) => {
      try {
        set((state) => ({
          aiGenerating: { ...state.aiGenerating, [noteId]: true },
          aiErrors: { ...state.aiErrors, [noteId]: undefined },
        }));

        // è°ƒç”¨AIæœåŠ¡
        await aiService.generateNote({
          noteId,
          prompt,
          onStream: (content) =>
            get().updateAIStreamingContent(noteId, content),
          onComplete: (finalContent, aiData) =>
            get().completeAIGeneration(noteId, finalContent, aiData),
          onError: (error) =>
            set((state) => ({
              aiErrors: { ...state.aiErrors, [noteId]: error.message },
              aiGenerating: { ...state.aiGenerating, [noteId]: false },
            })),
        });
      } catch (error) {
        console.error("AIç”Ÿæˆå¤±è´¥:", error);
        set((state) => ({
          aiErrors: { ...state.aiErrors, [noteId]: error.message },
          aiGenerating: { ...state.aiGenerating, [noteId]: false },
        }));
      }
    },

    // æ–°å¢ï¼šæ›´æ–°æµå¼å†…å®¹
    updateAIStreamingContent: (noteId: string, content: string) => {
      set((state) => ({
        aiStreamingData: { ...state.aiStreamingData, [noteId]: content },
      }));
    },

    // æ–°å¢ï¼šå®ŒæˆAIç”Ÿæˆ
    completeAIGeneration: async (
      noteId: string,
      finalContent: string,
      aiData: any
    ) => {
      try {
        // æ›´æ–°ä¾¿ç­¾å†…å®¹å’ŒAIæ•°æ®
        await get().updateNote(noteId, {
          content: finalContent,
          customProperties: {
            ...get().notes.find((n) => n.id === noteId)?.customProperties,
            ai: aiData,
          },
        });

        // æ¸…ç†ä¸´æ—¶çŠ¶æ€
        set((state) => ({
          aiGenerating: { ...state.aiGenerating, [noteId]: false },
          aiStreamingData: { ...state.aiStreamingData, [noteId]: undefined },
        }));

        console.log(`âœ… AIç”Ÿæˆå®Œæˆï¼Œä¾¿ç­¾ID: ${noteId}`);
      } catch (error) {
        console.error("ä¿å­˜AIç”Ÿæˆå†…å®¹å¤±è´¥:", error);
        set((state) => ({
          aiErrors: { ...state.aiErrors, [noteId]: error.message },
          aiGenerating: { ...state.aiGenerating, [noteId]: false },
        }));
      }
    },

    // æ–°å¢ï¼šåˆ‡æ¢æ€ç»´é“¾æ˜¾ç¤º
    toggleThinkingChain: async (noteId: string) => {
      const note = get().notes.find((n) => n.id === noteId);
      if (note?.customProperties?.ai) {
        const currentShow = note.customProperties.ai.showThinking ?? true;
        await get().updateNote(noteId, {
          customProperties: {
            ...note.customProperties,
            ai: {
              ...note.customProperties.ai,
              showThinking: !currentShow,
            },
          },
        });
      }
    },
  }))
);
```

## 6. AI æœåŠ¡å±‚è®¾è®¡ï¼ˆæ¶æ„å¸ˆä¼˜åŒ–ï¼‰

### 6.1 éµå¾ªç°æœ‰æœåŠ¡æ¨¡å¼

**å‚è€ƒç°æœ‰ `noteService.ts` çš„è®¾è®¡æ¨¡å¼**ï¼š

```typescript
// src/services/aiService.ts
import { AICustomProperties } from "../types/ai";

interface AIGenerationOptions {
  noteId: string;
  prompt: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  onStream?: (content: string) => void;
  onComplete?: (finalContent: string, aiData: AICustomProperties["ai"]) => void;
  onError?: (error: Error) => void;
}

interface AIProvider {
  name: string;
  generateContent: (options: AIGenerationOptions) => Promise<void>;
  supportedModels: string[];
  supportsStreaming: boolean;
  supportsThinking: boolean;
}

class AIService {
  private providers: Map<string, AIProvider> = new Map();
  private currentProvider: string = "zhipu";

  constructor() {
    this.initializeProviders();
  }

  private initializeProviders() {
    // æ™ºè°±AIæä¾›å•†
    this.providers.set("zhipu", new ZhipuAIProvider());

    // OpenAIæä¾›å•†
    this.providers.set("openai", new OpenAIProvider());
  }

  async generateNote(options: AIGenerationOptions): Promise<void> {
    try {
      const provider = this.providers.get(this.currentProvider);
      if (!provider) {
        throw new Error(`AIæä¾›å•† ${this.currentProvider} ä¸å¯ç”¨`);
      }

      await provider.generateContent(options);
    } catch (error) {
      console.error("AIç”Ÿæˆå¤±è´¥:", error);
      options.onError?.(error as Error);
      throw error;
    }
  }

  setProvider(providerName: string) {
    if (this.providers.has(providerName)) {
      this.currentProvider = providerName;
    } else {
      throw new Error(`ä¸æ”¯æŒçš„AIæä¾›å•†: ${providerName}`);
    }
  }

  getAvailableProviders(): string[] {
    return Array.from(this.providers.keys());
  }
}

// æ™ºè°±AIæä¾›å•†å®ç°
class ZhipuAIProvider implements AIProvider {
  name = "zhipu";
  supportedModels = ["glm-4", "glm-4-plus"];
  supportsStreaming = true;
  supportsThinking = true;

  async generateContent(options: AIGenerationOptions): Promise<void> {
    const apiKey = this.getApiKey();
    if (!apiKey) {
      throw new Error("æ™ºè°±AI APIå¯†é’¥æœªé…ç½®");
    }

    try {
      const response = await fetch(
        "https://open.bigmodel.cn/api/paas/v4/chat/completions",
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            model: options.model || "glm-4",
            messages: [
              {
                role: "user",
                content: options.prompt,
              },
            ],
            stream: true,
            temperature: options.temperature || 0.7,
            max_tokens: options.maxTokens || 1000,
          }),
        }
      );

      if (!response.ok) {
        throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.statusText}`);
      }

      await this.handleStreamResponse(response, options);
    } catch (error) {
      console.error("æ™ºè°±AI APIè°ƒç”¨å¤±è´¥:", error);
      throw error;
    }
  }

  private async handleStreamResponse(
    response: Response,
    options: AIGenerationOptions
  ) {
    const reader = response.body?.getReader();
    if (!reader) throw new Error("æ— æ³•è¯»å–å“åº”æµ");

    let fullContent = "";
    let thinkingChain: any[] = [];

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = new TextDecoder().decode(value);
        const lines = chunk.split("\n").filter((line) => line.trim());

        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.slice(6);
            if (data === "[DONE]") continue;

            try {
              const parsed = JSON.parse(data);
              const content = parsed.choices?.[0]?.delta?.content || "";

              if (content) {
                fullContent += content;
                options.onStream?.(fullContent);
              }

              // è§£ææ€ç»´é“¾ï¼ˆå¦‚æœæ”¯æŒï¼‰
              if (parsed.choices?.[0]?.delta?.thinking) {
                thinkingChain.push({
                  id: `step_${thinkingChain.length + 1}`,
                  content: parsed.choices[0].delta.thinking,
                  timestamp: Date.now(),
                });
              }
            } catch (e) {
              console.warn("è§£æå“åº”æ•°æ®å¤±è´¥:", e);
            }
          }
        }
      }

      // æ„é€ AIæ•°æ®
      const aiData: AICustomProperties["ai"] = {
        generated: true,
        model: options.model || "glm-4",
        provider: "zhipu",
        generatedAt: new Date().toISOString(),
        prompt: options.prompt,
        requestId: `req_${Date.now()}`,
        showThinking: true,
        thinkingCollapsed: false,
      };

      if (thinkingChain.length > 0) {
        aiData.thinkingChain = {
          steps: thinkingChain,
          summary: `é€šè¿‡${thinkingChain.length}æ­¥æ¨ç†å®Œæˆ`,
          totalSteps: thinkingChain.length,
        };
      }

      options.onComplete?.(fullContent, aiData);
    } finally {
      reader.releaseLock();
    }
  }

  private getApiKey(): string | null {
    return localStorage.getItem("ai_zhipu_api_key");
  }
}

export const aiService = new AIService();
```

## 7. ç»„ä»¶å®ç°ï¼ˆæ¶æ„å¸ˆä¼˜åŒ–ï¼‰

### 7.1 æ€ç»´é“¾æ˜¾ç¤ºç»„ä»¶

```tsx
// src/components/TiptapEditor/ThinkingChainDisplay.tsx
import React, { memo, useState } from "react";
import { Collapse, Typography, Tag } from "antd";
import { BrainOutlined, ClockCircleOutlined } from "@ant-design/icons";
import styles from "./ThinkingChainDisplay.module.css";

interface ThinkingChainDisplayProps {
  thinkingData: {
    steps: Array<{
      id: string;
      content: string;
      timestamp: number;
    }>;
    summary: string;
    totalSteps: number;
  };
  isCollapsed: boolean;
  onToggle: () => void;
}

export const ThinkingChainDisplay = memo<ThinkingChainDisplayProps>(
  ({ thinkingData, isCollapsed, onToggle }) => {
    const formatTime = (timestamp: number) => {
      return new Date(timestamp).toLocaleTimeString();
    };

    const items = [
      {
        key: "thinking",
        label: (
          <div className={styles.thinkingHeader}>
            <BrainOutlined className={styles.thinkingIcon} />
            <span>AI æ€ç»´è¿‡ç¨‹</span>
            <Tag color="blue" className={styles.stepCount}>
              {thinkingData.totalSteps} æ­¥
            </Tag>
          </div>
        ),
        children: (
          <div className={styles.thinkingContent}>
            {thinkingData.steps.map((step, index) => (
              <div key={step.id} className={styles.thinkingStep}>
                <div className={styles.stepHeader}>
                  <span className={styles.stepNumber}>æ­¥éª¤ {index + 1}</span>
                  <span className={styles.stepTime}>
                    <ClockCircleOutlined /> {formatTime(step.timestamp)}
                  </span>
                </div>
                <div className={styles.stepContent}>{step.content}</div>
              </div>
            ))}
            <div className={styles.thinkingSummary}>
              <Typography.Text type="secondary">
                ğŸ’¡ {thinkingData.summary}
              </Typography.Text>
            </div>
          </div>
        ),
      },
    ];

    return (
      <div className={styles.thinkingChainContainer}>
        <Collapse
          items={items}
          activeKey={isCollapsed ? [] : ["thinking"]}
          onChange={onToggle}
          ghost
          size="small"
        />
      </div>
    );
  }
);
```

### 7.2 AI è®¾ç½®æ ‡ç­¾é¡µ

```tsx
// src/components/SettingsModal/tabs/AISettingsTab.tsx
import React, { memo, useState, useEffect } from "react";
import { Form, Input, Select, Slider, Switch, Button, message } from "antd";
import { RobotOutlined, KeyOutlined } from "@ant-design/icons";
import { aiService } from "../../../services/aiService";
import styles from "../SettingsModal.module.css";

interface AISettings {
  provider: string;
  apiKeys: Record<string, string>;
  defaultModel: string;
  temperature: number;
  maxTokens: number;
  showThinking: boolean;
  autoSave: boolean;
}

export const AISettingsTab = memo(() => {
  const [form] = Form.useForm();
  const [settings, setSettings] = useState<AISettings>({
    provider: "zhipu",
    apiKeys: {},
    defaultModel: "glm-4",
    temperature: 0.7,
    maxTokens: 1000,
    showThinking: true,
    autoSave: true,
  });
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadSettings();
  }, []);

  const loadSettings = () => {
    try {
      const savedSettings = localStorage.getItem("ai_settings");
      if (savedSettings) {
        const parsed = JSON.parse(savedSettings);
        setSettings(parsed);
        form.setFieldsValue(parsed);
      }
    } catch (error) {
      console.error("åŠ è½½AIè®¾ç½®å¤±è´¥:", error);
    }
  };

  const saveSettings = async (values: AISettings) => {
    setLoading(true);
    try {
      // ä¿å­˜APIå¯†é’¥åˆ°ç‹¬ç«‹çš„å­˜å‚¨
      Object.entries(values.apiKeys).forEach(([provider, key]) => {
        if (key) {
          localStorage.setItem(`ai_${provider}_api_key`, key);
        }
      });

      // ä¿å­˜å…¶ä»–è®¾ç½®
      const settingsToSave = { ...values };
      delete settingsToSave.apiKeys; // ä¸ä¿å­˜æ˜æ–‡å¯†é’¥
      localStorage.setItem("ai_settings", JSON.stringify(settingsToSave));

      // æ›´æ–°AIæœåŠ¡é…ç½®
      aiService.setProvider(values.provider);

      setSettings(values);
      message.success("AIè®¾ç½®å·²ä¿å­˜");
    } catch (error) {
      console.error("ä¿å­˜AIè®¾ç½®å¤±è´¥:", error);
      message.error("ä¿å­˜è®¾ç½®å¤±è´¥");
    } finally {
      setLoading(false);
    }
  };

  const testConnection = async () => {
    const values = form.getFieldsValue();
    setLoading(true);
    try {
      // æµ‹è¯•APIè¿æ¥
      message.info("æ­£åœ¨æµ‹è¯•è¿æ¥...");
      // è¿™é‡Œå¯ä»¥å®ç°å®é™…çš„è¿æ¥æµ‹è¯•
      message.success("è¿æ¥æµ‹è¯•æˆåŠŸ");
    } catch (error) {
      message.error("è¿æ¥æµ‹è¯•å¤±è´¥");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.tabContent}>
      <Form
        form={form}
        layout="vertical"
        initialValues={settings}
        onFinish={saveSettings}
        className={styles.settingsForm}
      >
        <Form.Item
          label="AI æœåŠ¡æä¾›å•†"
          name="provider"
          rules={[{ required: true, message: "è¯·é€‰æ‹©AIæœåŠ¡æä¾›å•†" }]}
        >
          <Select>
            <Select.Option value="zhipu">æ™ºè°±AI (GLM)</Select.Option>
            <Select.Option value="openai">OpenAI (GPT)</Select.Option>
          </Select>
        </Form.Item>

        <Form.Item
          label="API å¯†é’¥"
          name={["apiKeys", form.getFieldValue("provider")]}
          rules={[{ required: true, message: "è¯·è¾“å…¥APIå¯†é’¥" }]}
        >
          <Input.Password
            prefix={<KeyOutlined />}
            placeholder="è¯·è¾“å…¥APIå¯†é’¥"
          />
        </Form.Item>

        <Form.Item label="é»˜è®¤æ¨¡å‹" name="defaultModel">
          <Select>
            <Select.Option value="glm-4">GLM-4</Select.Option>
            <Select.Option value="glm-4-plus">GLM-4 Plus</Select.Option>
          </Select>
        </Form.Item>

        <Form.Item label="åˆ›æ„åº¦" name="temperature">
          <Slider
            min={0}
            max={1}
            step={0.1}
            marks={{
              0: "ä¿å®ˆ",
              0.5: "é€‚ä¸­",
              1: "åˆ›æ„",
            }}
          />
        </Form.Item>

        <Form.Item label="æœ€å¤§è¾“å‡ºé•¿åº¦" name="maxTokens">
          <Slider
            min={100}
            max={2000}
            step={100}
            marks={{
              100: "100",
              1000: "1000",
              2000: "2000",
            }}
          />
        </Form.Item>

        <Form.Item name="showThinking" valuePropName="checked">
          <Switch checkedChildren="æ˜¾ç¤º" unCheckedChildren="éšè—" />
          <span style={{ marginLeft: 8 }}>æ˜¾ç¤ºAIæ€ç»´è¿‡ç¨‹</span>
        </Form.Item>

        <Form.Item name="autoSave" valuePropName="checked">
          <Switch checkedChildren="å¼€å¯" unCheckedChildren="å…³é—­" />
          <span style={{ marginLeft: 8 }}>è‡ªåŠ¨ä¿å­˜AIç”Ÿæˆçš„å†…å®¹</span>
        </Form.Item>

        <Form.Item>
          <Button.Group>
            <Button onClick={testConnection} loading={loading}>
              æµ‹è¯•è¿æ¥
            </Button>
            <Button type="primary" htmlType="submit" loading={loading}>
              ä¿å­˜è®¾ç½®
            </Button>
          </Button.Group>
        </Form.Item>
      </Form>
    </div>
  );
});
```

## 8. å®‰å…¨æ€§ä¸æ€§èƒ½è€ƒè™‘ï¼ˆæ¶æ„å¸ˆè¡¥å……ï¼‰

### 8.1 API å¯†é’¥å®‰å…¨ç®¡ç†

```typescript
// src/utils/security.ts
class SecurityManager {
  private static instance: SecurityManager;

  private constructor() {}

  static getInstance(): SecurityManager {
    if (!SecurityManager.instance) {
      SecurityManager.instance = new SecurityManager();
    }
    return SecurityManager.instance;
  }

  // å®‰å…¨å­˜å‚¨APIå¯†é’¥
  setAPIKey(provider: string, key: string): void {
    try {
      // ç®€å•çš„æœ¬åœ°åŠ å¯†ï¼ˆç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨æ›´å¼ºçš„åŠ å¯†ï¼‰
      const encrypted = btoa(key);
      localStorage.setItem(`ai_${provider}_api_key`, encrypted);
    } catch (error) {
      console.error("å­˜å‚¨APIå¯†é’¥å¤±è´¥:", error);
      throw new Error("å¯†é’¥å­˜å‚¨å¤±è´¥");
    }
  }

  // å®‰å…¨è·å–APIå¯†é’¥
  getAPIKey(provider: string): string | null {
    try {
      const encrypted = localStorage.getItem(`ai_${provider}_api_key`);
      if (!encrypted) return null;

      return atob(encrypted);
    } catch (error) {
      console.error("è·å–APIå¯†é’¥å¤±è´¥:", error);
      return null;
    }
  }

  // éªŒè¯APIå¯†é’¥æ ¼å¼
  validateAPIKey(provider: string, key: string): boolean {
    const patterns = {
      zhipu: /^[a-zA-Z0-9]{32,}$/,
      openai: /^sk-[a-zA-Z0-9]{48}$/,
    };

    const pattern = patterns[provider as keyof typeof patterns];
    return pattern ? pattern.test(key) : false;
  }

  // æ¸…ç†APIå¯†é’¥
  clearAPIKey(provider: string): void {
    localStorage.removeItem(`ai_${provider}_api_key`);
  }
}

export const securityManager = SecurityManager.getInstance();
```

### 8.2 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```typescript
// src/hooks/useAIGeneration.ts
import { useCallback, useRef } from "react";
import { useNoteStore } from "../store/noteStore";
import { aiService } from "../services/aiService";

export const useAIGeneration = (noteId: string) => {
  const {
    aiGenerating,
    aiStreamingData,
    aiErrors,
    startAIGeneration,
    cancelAIGeneration,
  } = useNoteStore();

  const abortControllerRef = useRef<AbortController | null>(null);

  // é˜²æŠ–çš„ç”Ÿæˆå‡½æ•°
  const debouncedGenerate = useCallback(
    debounce(async (prompt: string) => {
      try {
        // å–æ¶ˆä¹‹å‰çš„è¯·æ±‚
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
        }

        abortControllerRef.current = new AbortController();
        await startAIGeneration(noteId, prompt);
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error("AIç”Ÿæˆå¤±è´¥:", error);
        }
      }
    }, 1000),
    [noteId, startAIGeneration]
  );

  const cancelGeneration = useCallback(() => {
    abortControllerRef.current?.abort();
    cancelAIGeneration(noteId);
  }, [noteId, cancelAIGeneration]);

  return {
    isGenerating: aiGenerating[noteId] || false,
    streamingContent: aiStreamingData[noteId] || "",
    error: aiErrors[noteId],
    generate: debouncedGenerate,
    cancel: cancelGeneration,
  };
};

// é˜²æŠ–å·¥å…·å‡½æ•°
function debounce<T extends (...args: any[]) => any>(
  func: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout;

  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func(...args), delay);
  };
}
```

## 9. å®æ–½è·¯çº¿å›¾

### 9.1 MVP é˜¶æ®µï¼ˆ1-2 å‘¨ï¼‰

**ç¬¬ä¸€å‘¨**ï¼š

- [ ] æ‰©å±• noteStore æ·»åŠ  AI æ–¹æ³•
- [ ] å®ç°åŸºç¡€çš„ aiService å’Œæ™ºè°± AI æä¾›å•†
- [ ] åœ¨ NoteToolbar æ·»åŠ  AI æŒ‰é’®
- [ ] å®ç°åŸºæœ¬çš„ AI ç”ŸæˆåŠŸèƒ½

**ç¬¬äºŒå‘¨**ï¼š

- [ ] åœ¨ TiptapEditor ä¸­é›†æˆæ€ç»´é“¾æ˜¾ç¤º
- [ ] æ·»åŠ  AI è®¾ç½®æ ‡ç­¾é¡µ
- [ ] å®ç°æµå¼ç”Ÿæˆå’Œé”™è¯¯å¤„ç†
- [ ] åŸºç¡€æµ‹è¯•å’Œè°ƒè¯•

### 9.2 åŠŸèƒ½å®Œå–„é˜¶æ®µï¼ˆ3-4 å‘¨ï¼‰

**ç¬¬ä¸‰å‘¨**ï¼š

- [ ] ä¼˜åŒ–æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ
- [ ] æ·»åŠ å¤š AI æä¾›å•†æ”¯æŒ
- [ ] å®Œå–„å®‰å…¨æ€§æªæ–½
- [ ] æ·»åŠ ä½¿ç”¨ç»Ÿè®¡å’Œæˆæœ¬è·Ÿè¸ª

**ç¬¬å››å‘¨**ï¼š

- [ ] å…¨é¢æµ‹è¯•å’Œ bug ä¿®å¤
- [ ] ç”¨æˆ·æ–‡æ¡£å’Œå¸®åŠ©
- [ ] ä»£ç ä¼˜åŒ–å’Œé‡æ„
- [ ] å‡†å¤‡å‘å¸ƒ

## 10. æ€»ç»“

ç»è¿‡ä¸“ä¸šæ¶æ„å¸ˆå®¡æŸ¥ï¼Œæœ¬æŒ‡å—å·²é’ˆå¯¹ç°æœ‰é¡¹ç›®æ¶æ„è¿›è¡Œäº†å…¨é¢ä¼˜åŒ–ï¼š

**âœ… æ¶æ„ä¸€è‡´æ€§**ï¼šå®Œå…¨éµå¾ªç°æœ‰çš„ç»„ä»¶ã€æœåŠ¡å’ŒçŠ¶æ€ç®¡ç†æ¨¡å¼
**âœ… æœ€å°ä¾µå…¥**ï¼šå……åˆ†åˆ©ç”¨ `customProperties` å­—æ®µï¼Œæ— éœ€ schema å˜æ›´
**âœ… æ€§èƒ½ä¼˜åŒ–**ï¼šé›†æˆç°æœ‰çš„é˜²æŠ–ã€é”™è¯¯å¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–æœºåˆ¶
**âœ… æ‰©å±•æ€§**ï¼šä¸ºæœªæ¥åŠŸèƒ½é¢„ç•™äº†åˆç†çš„æ‰©å±•ç©ºé—´
**âœ… å®‰å…¨è€ƒè™‘**ï¼šæä¾›äº† API å¯†é’¥ç®¡ç†å’Œæ•°æ®å®‰å…¨æªæ–½

éµå¾ªæœ¬æŒ‡å—å®æ–½ï¼Œå¯ä»¥ç¡®ä¿ AI åŠŸèƒ½ä¸ç°æœ‰æ¶æ„çš„å®Œç¾èåˆï¼ŒåŒæ—¶ä¸ºé¡¹ç›®çš„é•¿æœŸå‘å±•æ‰“ä¸‹åšå®åŸºç¡€ã€‚
