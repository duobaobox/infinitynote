# ä¾¿ç­¾é“¾æ¥æ’æ§½æ±‡æ€»åŠŸèƒ½å¤åˆ»æŒ‡å—

## æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»äº†æ— é™ä¾¿ç­¾é¡¹ç›®ä¸­çš„ä¾¿ç­¾é“¾æ¥æ’æ§½æ±‡æ€»åŠŸèƒ½çš„å®ç°åŸç†å’Œå¤åˆ»æ­¥éª¤ã€‚è¯¥åŠŸèƒ½å…è®¸ç”¨æˆ·å°†å¤šä¸ªä¾¿ç­¾è¿æ¥åˆ°æ’æ§½ä¸­ï¼Œç„¶åé€šè¿‡ AI ç”Ÿæˆæ±‡æ€»å†…å®¹ï¼Œæ”¯æŒä¸¤ç§ç”Ÿæˆæ¨¡å¼ï¼šæ±‡æ€»æ¨¡å¼å’Œæ›¿æ¢æ¨¡å¼ã€‚

## æ ¸å¿ƒåŠŸèƒ½æ¶æ„

### 1. åŠŸèƒ½ç»„æˆ

- **ä¾¿ç­¾è¿æ¥ç‚¹**ï¼šæ¯ä¸ªä¾¿ç­¾å·¦ä¸‹è§’çš„è¿æ¥ç‚¹ï¼Œç”¨äºå»ºç«‹è¿æ¥
- **ä¾¿ç­¾æ’æ§½å®¹å™¨**ï¼šåº•éƒ¨çš„æ’æ§½å®¹å™¨ï¼Œæ˜¾ç¤ºå·²è¿æ¥çš„ä¾¿ç­¾
- **è¿æ¥çº¿ç®¡ç†**ï¼šå¯è§†åŒ–è¿æ¥çº¿ï¼Œè¿æ¥ä¾¿ç­¾ä¸æ’æ§½
- **AI ç”Ÿæˆæ¨¡å¼**ï¼šæ”¯æŒæ±‡æ€»æ¨¡å¼å’Œæ›¿æ¢æ¨¡å¼çš„ AI å†…å®¹ç”Ÿæˆ
- **æº¯æºè¿½è¸ª**ï¼šè®°å½•ä¾¿ç­¾çš„ç”Ÿæˆæ¥æºå’Œä¾èµ–å…³ç³»

### 2. æŠ€æœ¯æ ˆ

- **React 18** + **TypeScript**ï¼šå‰ç«¯æ¡†æ¶å’Œç±»å‹ç³»ç»Ÿ
- **Zustand**ï¼šçŠ¶æ€ç®¡ç†
- **Leader Line**ï¼šè¿æ¥çº¿ç»˜åˆ¶åº“
- **Ant Design**ï¼šUI ç»„ä»¶åº“
- **IndexedDB**ï¼šæœ¬åœ°æ•°æ®å­˜å‚¨

## è¯¦ç»†å®ç°æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šä¾¿ç­¾è¿æ¥ç‚¹å®ç°

#### 1.1 è¿æ¥ç‚¹ç»„ä»¶ç»“æ„

åœ¨ä¾¿ç­¾ç»„ä»¶ä¸­æ·»åŠ è¿æ¥ç‚¹ï¼š

```tsx
// src/components/notes/StickyNote.tsx
{
  /* è¿æ¥ç‚¹ - å§‹ç»ˆæ˜¾ç¤ºï¼Œç¼–è¾‘çŠ¶æ€ä¸‹éšè—ä½†ä¿ç•™åœ¨DOMä¸­ */
}
{
  !isStreaming && (
    <div
      className={`connection-point ${isConnected ? "connected" : ""} ${
        note.sourceNoteIds && note.sourceNoteIds.length > 0 ? "has-source" : ""
      } ${sourceConnectionsVisible ? "source-active" : ""} ${
        isSourceConnected ? "source-connected" : ""
      } ${isBeingSourceConnected ? "being-source-connected" : ""} ${
        note.isEditing ? "editing-hidden" : ""
      }`}
      onClick={note.isEditing ? undefined : handleConnectionClick}
      title={
        note.isEditing
          ? ""
          : isConnected
          ? "å·²è¿æ¥åˆ°æ’æ§½"
          : isSourceConnected
          ? "ä½œä¸ºæºä¾¿ç­¾è¢«å…¶ä»–ä¾¿ç­¾å¼•ç”¨"
          : onConnect
          ? "ç‚¹å‡»è¿æ¥åˆ°æ’æ§½"
          : "ç‚¹å‡»æ·»åŠ åˆ°è¿æ¥æ’æ§½"
      }
      style={{
        pointerEvents: note.isEditing ? "none" : "auto",
      }}
    >
      <div className="connection-dot"></div>
    </div>
  );
}
```

#### 1.2 è¿æ¥ç‚¹æ ·å¼

```css
/* src/components/notes/StickyNote.css */
.connection-point {
  position: absolute;
  bottom: 8px; /* è°ƒæ•´åˆ°ä¾¿ç­¾å†…éƒ¨ï¼Œè·ç¦»åº•éƒ¨8px */
  left: 8px; /* è°ƒæ•´åˆ°ä¾¿ç­¾å†…éƒ¨ï¼Œè·ç¦»å·¦è¾¹8px */
  width: 18px; /* ä¸æ’æ§½å°ºå¯¸ç»Ÿä¸€ */
  height: 18px; /* ä¸æ’æ§½å°ºå¯¸ç»Ÿä¸€ */
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(22, 119, 255, 0.2);
  cursor: pointer;
  transition: all 0.2s ease;
  opacity: 0; /* é»˜è®¤éšè—ï¼Œæ‚¬åœæ—¶æ˜¾ç¤º */
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ä¾¿ç­¾æ‚¬åœæ—¶æ˜¾ç¤ºè¿æ¥ç‚¹ */
.sticky-note:hover .connection-point {
  opacity: 1;
}

/* è¿æ¥ç‚¹å†…éƒ¨çš„åœ†ç‚¹ */
.connection-dot {
  width: 15px;
  height: 15px;
  border-radius: 50%;
  background: #1677ff;
  border: 1px solid rgba(255, 255, 255, 1);
  transition: all 0.2s ease;
  margin: auto;
}

/* å·²è¿æ¥çŠ¶æ€çš„è¿æ¥ç‚¹ */
.connection-point.connected {
  opacity: 1; /* å·²è¿æ¥æ—¶å§‹ç»ˆæ˜¾ç¤º */
}

.connection-point.connected .connection-dot {
  background: #52c41a; /* ç»¿è‰²è¡¨ç¤ºå·²è¿æ¥ */
  border-color: rgba(255, 255, 255, 1);
  animation: connectedPulse 4s ease-in-out infinite;
}

/* è¿æ¥çŠ¶æ€è„‰å†²åŠ¨ç”» */
@keyframes connectedPulse {
  0%,
  100% {
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12), 0 0 0 0 rgba(82, 196, 26, 0.2);
  }
  50% {
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12), 0 0 0 3px rgba(82, 196, 26, 0.15);
  }
}
```

### ç¬¬äºŒæ­¥ï¼šä¾¿ç­¾æ’æ§½å®¹å™¨å®ç°

#### 2.1 æ’æ§½å®¹å™¨ç»„ä»¶

```tsx
// src/components/canvas/StickyNoteSlots.tsx
import React from "react";
import { Tooltip } from "antd";
import type { StickyNote } from "../types";
import { connectionUtils } from "../../stores/connectionStore";
import "./StickyNoteSlots.css";

// è¿æ¥æ¨¡å¼æšä¸¾
export const ConnectionMode = {
  SUMMARY: "summary", // æ±‡æ€»æ¨¡å¼ï¼šä¿ç•™åŸå§‹ä¾¿ç­¾ï¼Œå¹¶è‡ªåŠ¨å°†å®ƒä»¬è¿æ¥åˆ°æ–°ä¾¿ç­¾
  REPLACE: "replace", // æ›¿æ¢æ¨¡å¼ï¼šåˆ é™¤åŸå§‹ä¾¿ç­¾ï¼Œåªä¿ç•™æ–°ç”Ÿæˆçš„ä¾¿ç­¾
} as const;

// æ’æ§½ç»„ä»¶å±æ€§æ¥å£
interface StickyNoteSlotsProps {
  connectedNotes: StickyNote[]; // å·²è¿æ¥çš„ä¾¿ç­¾åˆ—è¡¨
  connectionMode: (typeof ConnectionMode)[keyof typeof ConnectionMode]; // è¿æ¥æ¨¡å¼
  onModeChange: (
    mode: (typeof ConnectionMode)[keyof typeof ConnectionMode]
  ) => void; // æ¨¡å¼åˆ‡æ¢å›è°ƒ
  onRemoveConnection: (noteId: string) => void; // ç§»é™¤è¿æ¥å›è°ƒ
  onClearAllConnections: () => void; // æ¸…ç©ºæ‰€æœ‰è¿æ¥å›è°ƒ
  visible?: boolean; // æ˜¯å¦æ˜¾ç¤ºæ’æ§½å®¹å™¨
}

const StickyNoteSlots: React.FC<StickyNoteSlotsProps> = ({
  connectedNotes,
  connectionMode,
  onModeChange,
  onRemoveConnection,
  onClearAllConnections,
  visible = true,
}) => {
  return (
    <div
      className={`slots-container ${
        visible && connectedNotes.length > 0 ? "visible" : ""
      }`}
      id="slots-container"
    >
      {/* æ’æ§½åˆ—è¡¨ */}
      <div className="slots-list" id="slots-list">
        {connectedNotes.length === 0 ? (
          <div className="empty-slots">
            <div className="empty-slot-circle">
              <span className="empty-slot-icon">â—‹</span>
            </div>
            <div className="empty-text-container">
              <span className="empty-text">æš‚æ— è¿æ¥çš„ä¾¿ç­¾</span>
              <span className="empty-hint">
                æ‚¬åœä¾¿ç­¾å¹¶ç‚¹å‡»å·¦ä¸‹è§’{" "}
                <span className="connection-dot-demo">â—</span> è¿æ¥ç‚¹æ¥å»ºç«‹è¿æ¥
              </span>
            </div>
          </div>
        ) : (
          connectedNotes.map((note, index) => (
            <div
              key={note.id}
              className="note-slot connected"
              data-note-id={note.id}
              data-index={index + 1}
              title={(() => {
                const displayedContent =
                  connectionUtils.getDisplayedNoteContent(note);
                return `${
                  note.title || "æ— æ ‡é¢˜ä¾¿ç­¾"
                }: ${displayedContent.substring(0, 50)}${
                  displayedContent.length > 50 ? "..." : ""
                }`;
              })()}
            >
              {/* åœ†å½¢æ’æ§½ */}
              <div className="slot-circle">
                <span className="slot-index">{index + 1}</span>
              </div>
              {/* åˆ é™¤æŒ‰é’® - ä½äºåœ†å½¢å³ä¸Šè§’ */}
              <div
                className="slot-remove"
                onClick={() => onRemoveConnection(note.id)}
                title="ç§»é™¤è¿æ¥"
              >
                Ã—
              </div>
            </div>
          ))
        )}
      </div>

      {/* è¿æ¥æ¨¡å¼åˆ‡æ¢å™¨ */}
      <Tooltip
        title={<div dangerouslySetInnerHTML={{ __html: getModeTooltip() }} />}
        placement="top"
        arrow={false}
        mouseEnterDelay={0.5}
      >
        <div className="mode-selector" id="connection-mode-selector">
          <button
            className={`mode-button ${
              connectionMode === ConnectionMode.SUMMARY ? "active" : ""
            }`}
            onClick={() => onModeChange(ConnectionMode.SUMMARY)}
          >
            æ±‡æ€»
          </button>
          <button
            className={`mode-button ${
              connectionMode === ConnectionMode.REPLACE ? "active" : ""
            }`}
            onClick={() => onModeChange(ConnectionMode.REPLACE)}
          >
            æ›¿æ¢
          </button>
        </div>
      </Tooltip>
    </div>
  );
};

export default StickyNoteSlots;
```

#### 2.2 æ’æ§½å®¹å™¨æ ·å¼

```css
/* src/components/canvas/StickyNoteSlots.css */
.slots-container {
  position: fixed;
  bottom: 90px; /* ä½äºæ§åˆ¶å°ä¸Šæ–¹ */
  left: 50%;
  transform: translateX(-50%);
  z-index: 98; /* ç•¥ä½äºæ§åˆ¶å° */
  max-width: 480px;
  width: 75%;
  min-width: 320px;
  margin-left: auto;
  margin-right: auto;

  /* å®¹å™¨æ ·å¼ - å®è‰²èƒŒæ™¯æé«˜æ€§èƒ½ */
  background: #ffffff;
  border-radius: 16px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08), 0 1px 3px rgba(0, 0, 0, 0.05);
  border: 1px solid rgba(22, 119, 255, 0.08);
  transition: opacity 0.2s ease-out;
  overflow: hidden;
  /* é»˜è®¤éšè—ï¼Œåªæœ‰åœ¨æœ‰è¿æ¥æ—¶æ‰æ˜¾ç¤º */
  opacity: 0;
  visibility: hidden;
  display: none;
}

.slots-container.visible {
  opacity: 1;
  visibility: visible;
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 6px 10px;
  height: 44px;
  box-sizing: border-box;
}

/* æ’æ§½åˆ—è¡¨å®¹å™¨ - æ¨ªæ’å¸ƒå±€ */
.slots-list {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 8px;
  overflow-x: auto;
  overflow-y: hidden;
  flex: 1;
  min-width: 0;
  padding: 0 4px;
  height: 100%;

  /* éšè—æ»šåŠ¨æ¡ä½†ä¿æŒæ»šåŠ¨åŠŸèƒ½ */
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.slots-list::-webkit-scrollbar {
  display: none;
}

/* ä¾¿ç­¾æ’æ§½æ ·å¼ - åœ†å½¢è®¾è®¡ */
.note-slot {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.2s ease;
  cursor: pointer;
}

/* åœ†å½¢æ’æ§½æ ·å¼ */
.slot-circle {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: rgba(22, 119, 255, 0.1);
  border: 1px solid rgba(22, 119, 255, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  position: relative;
  flex-shrink: 0;
}

.note-slot.connected .slot-circle {
  background: rgba(22, 119, 255, 0.2);
  border-color: #1677ff;
  box-shadow: 0 1px 4px rgba(22, 119, 255, 0.2);
  animation: slotConnectedPulse 4s ease-in-out infinite;
}

/* è¿æ¥çŠ¶æ€çš„è„‰å†²åŠ¨ç”» */
@keyframes slotConnectedPulse {
  0%,
  100% {
    box-shadow: 0 1px 4px rgba(22, 119, 255, 0.2), 0 0 0 0 rgba(22, 119, 255, 0.3);
  }
  50% {
    box-shadow: 0 1px 5px rgba(22, 119, 255, 0.25), 0 0 0 1px rgba(22, 119, 255, 0.15);
  }
}

/* æ’æ§½ç´¢å¼•æ•°å­— */
.slot-index {
  font-size: 9px;
  font-weight: 600;
  color: #1677ff;
  user-select: none;
}

/* ç§»é™¤æŒ‰é’® - ä½äºåœ†å½¢å³ä¸Šè§’ */
.slot-remove {
  position: absolute;
  top: -2px;
  right: -2px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: rgba(255, 77, 79, 0.9);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 10;
  border: 1px solid white;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.slot-remove:hover {
  background: #ff4d4f;
  transform: scale(1.15);
  box-shadow: 0 1px 4px rgba(255, 77, 79, 0.4);
}

/* æ¨¡å¼åˆ‡æ¢å™¨æ ·å¼ */
.mode-selector {
  display: flex;
  align-items: center;
  background-color: rgba(22, 119, 255, 0.08);
  border-radius: 6px;
  padding: 2px;
  margin-right: 12px;
  flex-shrink: 0;
  border: 1px solid rgba(22, 119, 255, 0.15);
}

.mode-button {
  background-color: transparent;
  border: none;
  color: rgba(22, 119, 255, 0.7);
  padding: 3px 8px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 10px;
  font-weight: 500;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.mode-button.active {
  background-color: #1677ff;
  color: white;
  box-shadow: 0 1px 3px rgba(22, 119, 255, 0.3);
}

.mode-button:not(.active):hover {
  background-color: rgba(22, 119, 255, 0.1);
  color: #1677ff;
}
```

### ç¬¬ä¸‰æ­¥ï¼šè¿æ¥çŠ¶æ€ç®¡ç†

#### 3.1 è¿æ¥çŠ¶æ€ Store

```typescript
// src/stores/connectionStore.ts
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import type { StickyNote } from "../components/types";
import { ConnectionMode } from "../components/canvas/StickyNoteSlots";
import { connectionLineManager } from "../utils/connectionLineManager";

// è¿æ¥æ¨¡å¼ç±»å‹
type ConnectionModeType = (typeof ConnectionMode)[keyof typeof ConnectionMode];

// è¿æ¥çŠ¶æ€æ¥å£
export interface ConnectionState {
  // è¿æ¥æ•°æ®
  connectedNotes: StickyNote[]; // å·²è¿æ¥çš„ä¾¿ç­¾åˆ—è¡¨
  connectionMode: ConnectionModeType; // è¿æ¥æ¨¡å¼
  maxConnections: number; // æœ€å¤§è¿æ¥æ•°é‡

  // çŠ¶æ€æ ‡è¯†
  isVisible: boolean; // æ’æ§½å®¹å™¨æ˜¯å¦å¯è§
}

// è¿æ¥æ“ä½œæ¥å£
export interface ConnectionActions {
  // è¿æ¥æ“ä½œ
  addConnection: (note: StickyNote) => boolean;
  removeConnection: (noteId: string) => void;
  clearAllConnections: () => void;

  // æ¨¡å¼ç®¡ç†
  setConnectionMode: (mode: ConnectionModeType) => void;

  // å¯è§æ€§ç®¡ç†
  setVisible: (visible: boolean) => void;

  // å·¥å…·æ–¹æ³•
  isNoteConnected: (noteId: string) => boolean;
  getConnectionIndex: (noteId: string) => number;
  canAddConnection: () => boolean;

  // è¿æ¥çº¿ç®¡ç†
  updateConnectionLines: (immediate?: boolean) => void;
}

// åˆ›å»ºè¿æ¥Store
export const useConnectionStore = create<ConnectionState & ConnectionActions>()(
  devtools(
    (set, get) => ({
      // åˆå§‹çŠ¶æ€
      connectedNotes: [],
      connectionMode: ConnectionMode.SUMMARY, // é»˜è®¤æ±‡æ€»æ¨¡å¼
      maxConnections: 10, // æœ€å¤§è¿æ¥10ä¸ªä¾¿ç­¾
      isVisible: false,

      // è¿æ¥æ“ä½œ
      addConnection: (note: StickyNote) => {
        const state = get();

        // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
        if (state.isNoteConnected(note.id)) {
          return false;
        }

        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§è¿æ¥æ•°
        if (!state.canAddConnection()) {
          return false;
        }

        // è®¡ç®—æ–°çš„è¿æ¥ç´¢å¼•
        const newIndex = state.connectedNotes.length + 1;

        // æ·»åŠ è¿æ¥
        const updatedNote = {
          ...note,
          isConnected: true,
          connectionIndex: newIndex,
        };

        set({
          connectedNotes: [...state.connectedNotes, updatedNote],
          isVisible: true, // æœ‰è¿æ¥æ—¶æ˜¾ç¤ºæ’æ§½å®¹å™¨
        });

        // ä½¿ç”¨requestAnimationFrameç¡®ä¿DOMå·²æ›´æ–°ï¼Œå‡å°‘å»¶è¿Ÿ
        requestAnimationFrame(async () => {
          await connectionLineManager.createConnection(updatedNote, newIndex);
        });

        return true;
      },

      removeConnection: (noteId: string) => {
        const state = get();

        // ç§»é™¤è¿æ¥çº¿
        connectionLineManager.removeConnection(noteId);

        const updatedNotes = state.connectedNotes.filter(
          (note) => note.id !== noteId
        );

        // é‡æ–°åˆ†é…è¿æ¥ç´¢å¼•
        const reindexedNotes = updatedNotes.map((note, index) => ({
          ...note,
          connectionIndex: index + 1,
        }));

        set({
          connectedNotes: reindexedNotes,
          isVisible: reindexedNotes.length > 0, // æ²¡æœ‰è¿æ¥æ—¶éšè—æ’æ§½å®¹å™¨
        });

        // ä½¿ç”¨requestAnimationFrameé‡æ–°åˆ›å»ºå‰©ä½™è¿æ¥çº¿ï¼Œå‡å°‘å»¶è¿Ÿ
        requestAnimationFrame(async () => {
          for (const note of reindexedNotes) {
            await connectionLineManager.createConnection(
              note,
              note.connectionIndex!
            );
          }
        });
      },

      clearAllConnections: () => {
        try {
          // è·å–å½“å‰çŠ¶æ€
          const state = get();
          const noteIds = state.connectedNotes.map((note) => note.id);

          console.log(
            "ğŸ”— ConnectionStore: æ¸…ç©ºæ‰€æœ‰è¿æ¥ï¼Œå½“å‰è¿æ¥æ•°:",
            noteIds.length
          );

          // æ¸…ç©ºæ‰€æœ‰è¿æ¥çº¿ï¼ˆåªæ¸…ç©ºæ™®é€šè¿æ¥çº¿ï¼Œä¿ç•™æº¯æºè¿æ¥çº¿ï¼‰
          connectionLineManager.clearAllConnections();

          // é‡ç½®çŠ¶æ€
          set({
            connectedNotes: [], // æ¸…ç©ºè¿æ¥çš„ä¾¿ç­¾åˆ—è¡¨
            isVisible: false, // éšè—æ’æ§½å®¹å™¨
          });

          console.log("âœ… ConnectionStore: è¿æ¥çŠ¶æ€å·²æ¸…ç©º");
        } catch (error) {
          console.error("âŒ ConnectionStore: æ¸…ç©ºè¿æ¥å¤±è´¥:", error);
          // å³ä½¿å‡ºé”™ä¹Ÿå°è¯•é‡ç½®çŠ¶æ€
          set({
            connectedNotes: [],
            isVisible: false,
          });
        }
      },

      // æ¨¡å¼ç®¡ç†
      setConnectionMode: (mode: ConnectionModeType) => {
        set({ connectionMode: mode });
      },

      // å¯è§æ€§ç®¡ç†
      setVisible: (visible: boolean) => {
        set({ isVisible: visible });
      },

      // å·¥å…·æ–¹æ³•
      isNoteConnected: (noteId: string) => {
        const state = get();
        return state.connectedNotes.some((note) => note.id === noteId);
      },

      getConnectionIndex: (noteId: string) => {
        const state = get();
        const note = state.connectedNotes.find((note) => note.id === noteId);
        return note?.connectionIndex || -1;
      },

      canAddConnection: () => {
        const state = get();
        return state.connectedNotes.length < state.maxConnections;
      },

      // ä¼˜åŒ–åçš„è¿æ¥çº¿ç®¡ç† - ç»Ÿä¸€æ¥å£ï¼Œæ”¯æŒç«‹å³æ›´æ–°é€‰é¡¹
      updateConnectionLines: (immediate: boolean = false) => {
        if (immediate) {
          connectionLineManager.updateConnectionPositionsImmediate();
        } else {
          connectionLineManager.updateConnectionPositions();
        }
      },
    }),
    {
      name: "connection-store", // DevToolsä¸­çš„åç§°
    }
  )
);
```

### ç¬¬å››æ­¥ï¼šè¿æ¥çº¿ç®¡ç†å™¨

#### 4.1 Leader Line åŠ è½½å™¨

```typescript
// src/utils/leaderLineLoader.ts
let LeaderLineClass: any = null;

// åŠ è½½ Leader Line
export const loadLeaderLine = async (): Promise<any> => {
  // å¦‚æœå·²ç»æœ‰ç¼“å­˜çš„å®ä¾‹ï¼Œç›´æ¥è¿”å›
  if (LeaderLineClass) {
    return LeaderLineClass;
  }

  // æ£€æŸ¥æ˜¯å¦åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­
  if (typeof window === "undefined" || typeof document === "undefined") {
    throw new Error("Leader Line éœ€è¦æµè§ˆå™¨ç¯å¢ƒ");
  }

  // æ£€æŸ¥å…¨å±€å˜é‡ï¼ˆå¯èƒ½å·²ç»é€šè¿‡ script æ ‡ç­¾åŠ è½½ï¼‰
  if ((window as any).LeaderLine) {
    LeaderLineClass = (window as any).LeaderLine;
    return LeaderLineClass;
  }

  // å¦‚æœæ²¡æœ‰é¢„åŠ è½½ï¼Œåˆ™åŠ¨æ€åŠ è½½
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = "/leader-line.min.js";

    const timeout = setTimeout(() => {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
      reject(new Error("Leader Line åŠ è½½è¶…æ—¶"));
    }, 8000); // 8ç§’è¶…æ—¶

    script.onload = () => {
      clearTimeout(timeout);
      if ((window as any).LeaderLine) {
        LeaderLineClass = (window as any).LeaderLine;
        resolve(LeaderLineClass);
      } else {
        reject(new Error("Leader Line åŠ è½½å¤±è´¥ï¼šæœªæ‰¾åˆ°å…¨å±€å˜é‡"));
      }
    };

    script.onerror = () => {
      clearTimeout(timeout);
      reject(new Error("Leader Line è„šæœ¬åŠ è½½å¤±è´¥"));
    };

    document.head.appendChild(script);
  });
};

// æ£€æŸ¥ Leader Line æ˜¯å¦å·²åŠ è½½
export const isLeaderLineLoaded = (): boolean => {
  return (
    LeaderLineClass !== null ||
    (typeof window !== "undefined" && !!(window as any).LeaderLine)
  );
};
```

#### 4.2 è¿æ¥çº¿ç®¡ç†å™¨æ ¸å¿ƒå®ç°

```typescript
// src/utils/connectionLineManager.ts
import { loadLeaderLine } from "./leaderLineLoader";
import type { StickyNote } from "../components/types";

class ConnectionLineManager {
  private connections = new Map<string, any>(); // å­˜å‚¨è¿æ¥çº¿å®ä¾‹
  private updateTimeout: NodeJS.Timeout | null = null;

  // ç”Ÿæˆè¿æ¥ID
  private getConnectionId(noteId: string, slotIndex: number): string {
    return `connection-${noteId}-${slotIndex}`;
  }

  // åˆ›å»ºè¿æ¥çº¿
  async createConnection(
    note: StickyNote,
    slotIndex: number
  ): Promise<boolean> {
    try {
      const connectionId = this.getConnectionId(note.id, slotIndex);

      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¿æ¥
      if (this.connections.has(connectionId)) {
        console.warn(`è¿æ¥çº¿ ${connectionId} å·²å­˜åœ¨`);
        return false;
      }

      // ä½¿ç”¨requestAnimationFrameç­‰å¾…DOMæ›´æ–°ï¼Œå‡å°‘å»¶è¿Ÿ
      await new Promise((resolve) => requestAnimationFrame(resolve));

      // è·å–ä¾¿ç­¾è¿æ¥ç‚¹å…ƒç´  - ä½¿ç”¨è¿æ¥ç‚¹å®¹å™¨ä½œä¸ºè¿æ¥ç›®æ ‡
      const noteElement = document.querySelector(`[data-note-id="${note.id}"]`);
      const connectionPoint = noteElement?.querySelector(
        ".connection-point"
      ) as HTMLElement;

      if (!connectionPoint) {
        console.error(`æœªæ‰¾åˆ°ä¾¿ç­¾ ${note.id} çš„è¿æ¥ç‚¹`);
        return false;
      }

      // è·å–æ’æ§½å…ƒç´ 
      const slotElement = document.querySelector(
        `[data-note-id="${note.id}"][data-index="${slotIndex}"]`
      ) as HTMLElement;

      if (!slotElement) {
        console.error(`æœªæ‰¾åˆ°æ’æ§½ ${slotIndex}`);
        return false;
      }

      // åŠ è½½Leader Line
      const LeaderLineClass = await loadLeaderLine();

      // å¼ºåˆ¶åˆ·æ–°å…ƒç´ ä½ç½®
      connectionPoint.getBoundingClientRect();
      slotElement.getBoundingClientRect();

      // åˆ›å»ºLeader Lineè¿æ¥çº¿ - ä½¿ç”¨è´å¡å°”æ›²çº¿ï¼Œæ— ç«¯ç‚¹åœ†ç‚¹
      const line = new LeaderLineClass(connectionPoint, slotElement, {
        color: "#1677ff", // è“è‰²è¿æ¥çº¿
        size: 4, // çº¿æ¡ç²—ç»†
        path: "fluid", // ä½¿ç”¨æµç•…çš„è´å¡å°”æ›²çº¿
        startSocket: "auto", // è®©Leader Lineè‡ªåŠ¨é€‰æ‹©æœ€ä½³è¿æ¥ç‚¹
        endSocket: "auto", // è®©Leader Lineè‡ªåŠ¨é€‰æ‹©æœ€ä½³è¿æ¥ç‚¹
        startSocketGravity: "auto", // ä½¿ç”¨autoè®©Leader Lineè‡ªåŠ¨è®¡ç®—
        endSocketGravity: "auto", // ä½¿ç”¨autoè®©Leader Lineè‡ªåŠ¨è®¡ç®—
        startPlug: "behind", // éšè—èµ·å§‹ç‚¹åœ†ç‚¹
        endPlug: "behind", // éšè—ç»“æŸç‚¹åœ†ç‚¹
        outline: true, // å¯ç”¨è½®å»“
        outlineColor: "rgba(255, 255, 255, 0.8)", // ç™½è‰²è½®å»“
        outlineSize: 1.2, // è½®å»“å¤§å°
        animate: {
          // è¿æ¥åŠ¨ç”»
          duration: 400,
          timing: "ease-in-out",
        },
      });

      // å­˜å‚¨è¿æ¥çº¿å®ä¾‹
      this.connections.set(connectionId, line);

      console.log(`âœ… è¿æ¥çº¿åˆ›å»ºæˆåŠŸ: ${connectionId}`);
      return true;
    } catch (error) {
      console.error(`âŒ åˆ›å»ºè¿æ¥çº¿å¤±è´¥:`, error);
      return false;
    }
  }

  // ç§»é™¤è¿æ¥çº¿
  removeConnection(noteId: string): void {
    try {
      // æŸ¥æ‰¾å¹¶ç§»é™¤æ‰€æœ‰ç›¸å…³çš„è¿æ¥çº¿
      const connectionsToRemove: string[] = [];

      for (const [connectionId, line] of this.connections.entries()) {
        if (connectionId.includes(noteId)) {
          connectionsToRemove.push(connectionId);
        }
      }

      // ç§»é™¤æ‰¾åˆ°çš„è¿æ¥çº¿
      for (const connectionId of connectionsToRemove) {
        const line = this.connections.get(connectionId);
        if (line) {
          try {
            line.remove();
            this.connections.delete(connectionId);
            console.log(`âœ… è¿æ¥çº¿ç§»é™¤æˆåŠŸ: ${connectionId}`);
          } catch (error) {
            console.error(`âŒ ç§»é™¤è¿æ¥çº¿å¤±è´¥: ${connectionId}`, error);
            // å³ä½¿ç§»é™¤å¤±è´¥ï¼Œä¹Ÿè¦ä»Mapä¸­åˆ é™¤
            this.connections.delete(connectionId);
          }
        }
      }
    } catch (error) {
      console.error(`âŒ ç§»é™¤è¿æ¥çº¿å¤±è´¥:`, error);
    }
  }

  // æ¸…ç©ºæ‰€æœ‰è¿æ¥çº¿
  clearAllConnections(): void {
    try {
      console.log(
        `ğŸ”— ConnectionLineManager: å¼€å§‹æ¸…ç©ºæ‰€æœ‰è¿æ¥çº¿ï¼Œå½“å‰è¿æ¥æ•°: ${this.connections.size}`
      );

      // åªæ¸…ç©ºæ™®é€šè¿æ¥çº¿ï¼Œä¿ç•™æº¯æºè¿æ¥çº¿
      const connectionsToRemove: string[] = [];

      for (const [connectionId] of this.connections.entries()) {
        // åªæ¸…ç©ºä»¥ "connection-" å¼€å¤´çš„æ™®é€šè¿æ¥çº¿
        if (connectionId.startsWith("connection-")) {
          connectionsToRemove.push(connectionId);
        }
      }

      // ç§»é™¤æ™®é€šè¿æ¥çº¿
      for (const connectionId of connectionsToRemove) {
        const line = this.connections.get(connectionId);
        if (line) {
          try {
            line.remove();
            this.connections.delete(connectionId);
          } catch (error) {
            console.error(`âŒ ç§»é™¤è¿æ¥çº¿å¤±è´¥: ${connectionId}`, error);
            // å³ä½¿ç§»é™¤å¤±è´¥ï¼Œä¹Ÿè¦ä»Mapä¸­åˆ é™¤
            this.connections.delete(connectionId);
          }
        }
      }

      console.log(
        `âœ… ConnectionLineManager: æ™®é€šè¿æ¥çº¿æ¸…ç©ºå®Œæˆï¼Œç§»é™¤æ•°é‡: ${connectionsToRemove.length}`
      );
    } catch (error) {
      console.error(`âŒ ConnectionLineManager: æ¸…ç©ºè¿æ¥çº¿å¤±è´¥:`, error);
    }
  }

  // æ›´æ–°è¿æ¥çº¿ä½ç½®ï¼ˆé˜²æŠ–ç‰ˆæœ¬ï¼‰
  updateConnectionPositions(): void {
    if (this.updateTimeout) {
      clearTimeout(this.updateTimeout);
    }

    this.updateTimeout = setTimeout(() => {
      this.updateConnectionPositionsImmediate();
    }, 100); // 100msé˜²æŠ–
  }

  // ç«‹å³æ›´æ–°è¿æ¥çº¿ä½ç½®
  updateConnectionPositionsImmediate(): void {
    try {
      for (const [connectionId, line] of this.connections.entries()) {
        if (line && typeof line.position === "function") {
          try {
            line.position();
          } catch (error) {
            console.warn(`æ›´æ–°è¿æ¥çº¿ä½ç½®å¤±è´¥: ${connectionId}`, error);
          }
        }
      }
    } catch (error) {
      console.error("æ›´æ–°è¿æ¥çº¿ä½ç½®å¤±è´¥:", error);
    }
  }
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹
export const connectionLineManager = new ConnectionLineManager();
```

### ç¬¬äº”æ­¥ï¼šAI ç”Ÿæˆä¸ä¾¿ç­¾ä¼šä¸­ç”Ÿæˆæ¨¡å¼

#### 5.1 AI æœåŠ¡æ ¸å¿ƒå®ç°

```typescript
// src/services/ai/aiService.ts
import type { JSONContent } from "@tiptap/react";
import ContentFormatService from "../contentFormatService";

// AIä¾¿ç­¾æ•°æ®æ¥å£
interface StickyNoteData {
  title: string;
  content: JSONContent;
  color?: string;
  tags?: string[];
  thinkingChain?: ThinkingChain;
  hasThinking?: boolean;
}

// æ€ç»´é“¾æ¥å£
interface ThinkingChain {
  steps: ThinkingStep[];
  totalSteps: number;
  summary: string;
}

interface ThinkingStep {
  id: string;
  content: string;
  stepType: "analysis" | "reasoning" | "conclusion" | "question" | "idea";
  timestamp: Date;
  order: number;
}

class AIService {
  // æ™ºèƒ½è§£æAIå›å¤ï¼Œæ”¯æŒæ€ç»´é“¾
  parseResponseIntelligently(
    response: string,
    originalPrompt: string,
    showThinkingMode: boolean = false
  ): { success: boolean; notes: StickyNoteData[]; error?: string } {
    try {
      // æ£€æµ‹æ€ç»´é“¾æ ‡ç­¾
      const thinkingMatch = response.match(/<thinking>([\s\S]*?)<\/thinking>/i);
      const thinkMatch = response.match(/<think>([\s\S]*?)<\/think>/i);

      let thinkingContent = thinkingMatch?.[1] || thinkMatch?.[1];
      let thinkingChain: ThinkingChain | undefined;

      // å¦‚æœæœ‰æ€ç»´é“¾å†…å®¹ä¸”å¼€å¯æ˜¾ç¤ºæ¨¡å¼ï¼Œè§£ææ€ç»´é“¾
      if (thinkingContent && showThinkingMode) {
        thinkingChain = this.parseThinkingChain(thinkingContent.trim());
      }

      // æå–æœ€ç»ˆç­”æ¡ˆï¼ˆç§»é™¤æ€ç»´é“¾æ ‡ç­¾ï¼‰
      let cleanContent = response
        .replace(/<thinking>[\s\S]*?<\/thinking>/gi, "")
        .replace(/<think>[\s\S]*?<\/think>/gi, "")
        .trim();

      // å¦‚æœå†…å®¹ä¸ºç©ºï¼Œä½¿ç”¨åŸå§‹å“åº”
      if (!cleanContent) {
        cleanContent = response;
      }

      const note: StickyNoteData = {
        title: this.generateTitleFromContent(cleanContent),
        content: ContentFormatService.markdownToJson(cleanContent),
        thinkingChain,
        hasThinking: !!thinkingChain,
      };

      return { success: true, notes: [note] };
    } catch (error) {
      console.error("âŒ æ™ºèƒ½è§£æå¤±è´¥:", error);
      return { success: false, error: "è§£æAIå›å¤å¤±è´¥" };
    }
  }

  // è§£ææ€ç»´é“¾
  private parseThinkingChain(thinkingContent: string): ThinkingChain {
    // æŒ‰æ®µè½åˆ†å‰²æ€ç»´å†…å®¹
    const paragraphs = thinkingContent
      .split(/\n\s*\n/)
      .map((p) => p.trim())
      .filter((p) => p.length > 0);

    // æ­¥éª¤ç±»å‹è¯†åˆ«è§„åˆ™
    const stepTypeRules = [
      {
        type: "analysis" as const,
        keywords: ["åˆ†æ", "è§‚å¯Ÿ", "å‘ç°", "æ³¨æ„åˆ°", "å¯ä»¥çœ‹å‡º"],
      },
      {
        type: "reasoning" as const,
        keywords: ["å› ä¸º", "æ‰€ä»¥", "æ¨ç†", "é€»è¾‘", "åŸºäº", "è€ƒè™‘åˆ°"],
      },
      {
        type: "conclusion" as const,
        keywords: ["ç»“è®º", "æ€»ç»“", "å› æ­¤", "ç»¼ä¸Š", "æœ€ç»ˆ"],
      },
      {
        type: "question" as const,
        keywords: ["é—®é¢˜", "ç–‘é—®", "æ˜¯å¦", "å¦‚ä½•", "ä¸ºä»€ä¹ˆ"],
      },
      {
        type: "idea" as const,
        keywords: ["æƒ³æ³•", "å»ºè®®", "æ–¹æ¡ˆ", "ç­–ç•¥", "æ–¹æ³•"],
      },
    ];

    const steps = paragraphs.map((paragraph, index) => {
      // ä½¿ç”¨ä¼˜åŒ–çš„è§„åˆ™åŒ¹é…æ­¥éª¤ç±»å‹
      let stepType:
        | "analysis"
        | "reasoning"
        | "conclusion"
        | "question"
        | "idea" = "reasoning";

      for (const rule of stepTypeRules) {
        if (rule.keywords.some((keyword) => paragraph.includes(keyword))) {
          stepType = rule.type;
          break;
        }
      }

      return {
        id: `step-${Date.now()}-${index}-${Math.random()
          .toString(36)
          .substring(2, 8)}`,
        content: paragraph,
        stepType,
        timestamp: new Date(Date.now() + index * 100),
        order: index + 1,
      };
    });

    return {
      steps,
      totalSteps: steps.length,
      summary: `AIè¿›è¡Œäº†${steps.length}æ­¥æ€è€ƒï¼ŒåŒ…å«${
        steps.filter((s) => s.stepType === "analysis").length
      }ä¸ªåˆ†ææ­¥éª¤å’Œ${
        steps.filter((s) => s.stepType === "reasoning").length
      }ä¸ªæ¨ç†æ­¥éª¤ã€‚`,
    };
  }

  // ä»å†…å®¹ç”Ÿæˆæ ‡é¢˜
  private generateTitleFromContent(content: string): string {
    if (!content || content.trim().length === 0) {
      return "AIä¾¿ç­¾";
    }

    // æ¸…ç†å†…å®¹ï¼Œç§»é™¤Markdownæ ‡è®°
    const cleanContent = content
      .replace(/[#*`_~\[\]()]/g, "")
      .replace(/\s+/g, " ")
      .trim();

    // å–å‰30ä¸ªå­—ç¬¦ä½œä¸ºæ ‡é¢˜
    if (cleanContent.length > 30) {
      return cleanContent.substring(0, 30) + "...";
    }

    return cleanContent || "AIä¾¿ç­¾";
  }
}

export default new AIService();
```

#### 5.2 ä¾¿ç­¾ä¼šä¸­ç”Ÿæˆæ¨¡å¼å®ç°

```typescript
// src/components/canvas/InfiniteCanvasNew.tsx (AIç”Ÿæˆéƒ¨åˆ†)
const handleAIGenerate = async (prompt: string) => {
  try {
    // å¼€å§‹AIç”ŸæˆçŠ¶æ€
    startGeneration();

    // å¦‚æœæœ‰è¿æ¥çš„ä¾¿ç­¾ï¼Œå°†å…¶å†…å®¹åŒ…å«åœ¨æç¤ºä¸­
    let finalPrompt = prompt;
    if (connectedNotes.length > 0) {
      const { prompt: generatedPrompt } =
        connectionUtils.generateAIPromptWithConnections(prompt, connectedNotes);
      finalPrompt = generatedPrompt;
    }

    // è®¡ç®—ä¾¿ç­¾åˆ›å»ºä½ç½®ï¼ˆç”»å¸ƒä¸­å¿ƒé™„è¿‘ï¼‰
    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) {
      throw new Error("æ— æ³•è·å–ç”»å¸ƒä½ç½®");
    }

    const centerX = rect.width / 2;
    const centerY = rect.height / 2;

    // æ·»åŠ éšæœºåç§»ï¼Œé¿å…ä¾¿ç­¾é‡å 
    const randomRange = 150;
    const distributedScreenX =
      centerX + (Math.random() * randomRange - randomRange / 2);
    const distributedScreenY =
      centerY + (Math.random() * randomRange - randomRange / 2);

    // è½¬æ¢ä¸ºé€»è¾‘åæ ‡
    const logicalX =
      (distributedScreenX - canvasState.offsetX) / canvasState.scale;
    const logicalY =
      (distributedScreenY - canvasState.offsetY) / canvasState.scale;

    // å‡†å¤‡æº¯æºæ•°æ®
    let sourceNoteIds: string[] | undefined;
    let sourceNotesContent: SourceNoteContent[] | undefined;
    let generationMode: "summary" | "replace" | undefined;

    if (connectedNotes.length > 0) {
      generationMode = connectionMode;

      if (connectionMode === "summary") {
        // æ±‡æ€»æ¨¡å¼ï¼šåªè®°å½•æºä¾¿ç­¾ID
        sourceNoteIds = connectedNotes.map((note) => note.id);
      } else if (connectionMode === "replace") {
        // æ›¿æ¢æ¨¡å¼ï¼šä¿å­˜å®Œæ•´çš„åŸå§‹ä¾¿ç­¾å†…å®¹ï¼Œä¿æŒJSONæ ¼å¼
        sourceNotesContent = connectedNotes.map((note) => ({
          id: note.id,
          title: note.title,
          content: note.content, // ä¿æŒJSONContentæ ¼å¼
          color: note.color,
          createdAt: note.createdAt,
          deletedAt: new Date(), // è®°å½•åˆ é™¤æ—¶é—´
        }));
        // ç«‹å³åˆ é™¤æ—§ä¾¿ç­¾å¹¶æ¸…ç©ºè¿æ¥ï¼Œé˜²æ­¢æ–°ä¾¿ç­¾ç»§æ‰¿çŠ¶æ€
        connectedNotes.forEach((note) => deleteNote(note.id));
        clearAllConnections();
      }
    }

    // ç”Ÿæˆéšæœºé¢œè‰²
    const colors: Array<StickyNoteType["color"]> = [
      "yellow",
      "blue",
      "green",
      "pink",
      "purple",
    ];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];

    // ç”Ÿæˆä¾¿ç­¾æ ‡é¢˜ï¼šä½¿ç”¨ç”¨æˆ·çš„promptï¼Œé™åˆ¶é•¿åº¦é¿å…è¿‡é•¿
    const generateTitleFromPrompt = (prompt: string): string => {
      if (!prompt || prompt.trim().length === 0) {
        return "AIä¾¿ç­¾";
      }

      const cleanPrompt = prompt.trim().replace(/\s+/g, " ");

      if (cleanPrompt.length > 30) {
        return cleanPrompt.substring(0, 30) + "...";
      }

      return cleanPrompt;
    };

    const tempNote: StickyNoteType = {
      id: `ai-note-${Date.now()}-${Math.random()
        .toString(36)
        .substring(2, 11)}`,
      x: logicalX,
      y: logicalY,
      width: 380, // AIä¾¿ç­¾é»˜è®¤å®½åº¦
      height: 330, // AIä¾¿ç­¾é»˜è®¤é«˜åº¦
      content: ContentFormatService.markdownToJson(""),
      title: generateTitleFromPrompt(prompt),
      color: randomColor,
      isNew: false,
      zIndex: maxZ + 1,
      isEditing: false,
      isTitleEditing: false,
      createdAt: new Date(),
      updatedAt: new Date(),
      // æº¯æºç›¸å…³å±æ€§
      sourceNoteIds,
      sourceNotesContent,
      generationMode,
    };

    // æ·»åŠ ä¸´æ—¶ä¾¿ç­¾åˆ°æ•°æ®åº“ï¼ŒæŒ‡å®šä¸ºAIä¾¿ç­¾ç±»å‹
    const addedNote = await addNote(tempNote, "ai");

    // å¼€å§‹æµå¼ç”Ÿæˆ
    startStreamingNote(addedNote.id, addedNote);

    // è°ƒç”¨AIæœåŠ¡è¿›è¡Œæµå¼ç”Ÿæˆ
    await aiService.generateStreamingContent(finalPrompt, {
      onChunk: (chunk) => {
        // æ›´æ–°æµå¼å†…å®¹
        updateStreamingContent(addedNote.id, chunk);
      },
      onComplete: () => {
        // å®Œæˆç”Ÿæˆ
        finishGeneration();
      },
      onNoteComplete: async (_, noteData) => {
        // ä¸€æ¬¡æ€§æ›´æ–°æ‰€æœ‰æ•°æ®ï¼Œé¿å…å¤šæ¬¡æ•°æ®åº“æ“ä½œ
        const updateData: any = {
          content: noteData.content, // æœ€ç»ˆå†…å®¹
          color: tempNote.color, // ä¿æŒä¸´æ—¶ä¾¿ç­¾çš„é¢œè‰²
          title: tempNote.title, // ä¿æŒç”¨æˆ·promptä½œä¸ºæ ‡é¢˜ï¼Œä¸è¢«AIè¦†ç›–
          updatedAt: new Date(),
        };

        // å¦‚æœæœ‰æ€ç»´é“¾æ•°æ®ï¼Œæ·»åŠ åˆ°æ›´æ–°ä¸­
        if (noteData.thinkingChain) {
          updateData.thinkingChain = noteData.thinkingChain;
          updateData.hasThinking = true;
        }

        // ç›´æ¥æ›´æ–°ä¾¿ç­¾æ•°æ®
        await updateStickyNote(addedNote.id, updateData);

        // æ¸…ç†æµå¼çŠ¶æ€
        cancelStreamingNote(addedNote.id);
      },
      onError: (error) => {
        console.error("AIç”Ÿæˆå¤±è´¥:", error);
        cancelGeneration();
        // åˆ é™¤å¤±è´¥çš„ä¾¿ç­¾
        deleteNote(addedNote.id);
      },
    });
  } catch (error) {
    console.error("AIç”Ÿæˆè¿‡ç¨‹å¤±è´¥:", error);
    cancelGeneration();
  }
};
```

### ç¬¬å…­æ­¥ï¼šæº¯æºè¿æ¥çº¿å®ç°

#### 6.1 æº¯æºè¿æ¥çº¿ç®¡ç†

```typescript
// src/utils/connectionLineManager.ts (æº¯æºè¿æ¥çº¿éƒ¨åˆ†)
class ConnectionLineManager {
  // ç”Ÿæˆæº¯æºè¿æ¥ID
  private getSourceConnectionId(
    sourceNoteId: string,
    targetNoteId: string
  ): string {
    return `source-${sourceNoteId}-${targetNoteId}`;
  }

  // åˆ›å»ºæº¯æºè¿æ¥çº¿
  async createSourceConnection(
    sourceNoteId: string,
    targetNoteId: string
  ): Promise<boolean> {
    try {
      const connectionId = this.getSourceConnectionId(
        sourceNoteId,
        targetNoteId
      );

      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¿æ¥
      if (this.connections.has(connectionId)) {
        console.warn(`æº¯æºè¿æ¥çº¿ ${connectionId} å·²å­˜åœ¨`);
        return false;
      }

      // ç­‰å¾…DOMæ›´æ–°
      await new Promise((resolve) => requestAnimationFrame(resolve));

      // è·å–æºä¾¿ç­¾çš„è¿æ¥ç‚¹
      const sourceNoteElement = document.querySelector(
        `[data-note-id="${sourceNoteId}"]`
      );
      const sourceConnectionPoint = sourceNoteElement?.querySelector(
        ".connection-point"
      ) as HTMLElement;

      if (!sourceConnectionPoint) {
        console.error(`æœªæ‰¾åˆ°æºä¾¿ç­¾ ${sourceNoteId} çš„è¿æ¥ç‚¹`);
        return false;
      }

      // è·å–ç›®æ ‡ä¾¿ç­¾çš„è¿æ¥ç‚¹
      const targetNoteElement = document.querySelector(
        `[data-note-id="${targetNoteId}"]`
      );
      const targetConnectionPoint = targetNoteElement?.querySelector(
        ".connection-point"
      ) as HTMLElement;

      if (!targetConnectionPoint) {
        console.error(`æœªæ‰¾åˆ°ç›®æ ‡ä¾¿ç­¾ ${targetNoteId} çš„è¿æ¥ç‚¹`);
        return false;
      }

      // åŠ è½½Leader Line
      const LeaderLineClass = await loadLeaderLine();

      // å¼ºåˆ¶åˆ·æ–°å…ƒç´ ä½ç½®
      sourceConnectionPoint.getBoundingClientRect();
      targetConnectionPoint.getBoundingClientRect();

      // åˆ›å»ºæº¯æºè¿æ¥çº¿ - ä½¿ç”¨ä¸åŒçš„æ ·å¼
      const line = new LeaderLineClass(
        sourceConnectionPoint,
        targetConnectionPoint,
        {
          color: "#fa8c16", // æ©™è‰²è¿æ¥çº¿ï¼Œä¸æº¯æºè¿æ¥ç‚¹é¢œè‰²ä¸€è‡´
          size: 3, // ç¨ç»†ä¸€äº›
          path: "fluid", // ä½¿ç”¨æµç•…çš„è´å¡å°”æ›²çº¿
          startSocket: "auto",
          endSocket: "auto",
          startSocketGravity: "auto",
          endSocketGravity: "auto",
          startPlug: "behind", // éšè—èµ·å§‹ç‚¹åœ†ç‚¹
          endPlug: "behind", // éšè—ç»“æŸç‚¹åœ†ç‚¹
          outline: true, // å¯ç”¨è½®å»“
          outlineColor: "rgba(255, 255, 255, 0.9)", // ç™½è‰²è½®å»“
          outlineSize: 1, // è½®å»“å¤§å°
          dash: { len: 8, gap: 4 }, // è™šçº¿æ ·å¼ï¼ŒåŒºåˆ†æ™®é€šè¿æ¥çº¿
          animate: {
            // è¿æ¥åŠ¨ç”»
            duration: 500,
            timing: "ease-in-out",
          },
        }
      );

      // å­˜å‚¨è¿æ¥çº¿å®ä¾‹
      this.connections.set(connectionId, line);

      console.log(`âœ… æº¯æºè¿æ¥çº¿åˆ›å»ºæˆåŠŸ: ${connectionId}`);
      return true;
    } catch (error) {
      console.error(`âŒ åˆ›å»ºæº¯æºè¿æ¥çº¿å¤±è´¥:`, error);
      return false;
    }
  }

  // ç§»é™¤æ‰€æœ‰æŒ‡å‘ç‰¹å®šä¾¿ç­¾çš„æº¯æºè¿æ¥çº¿
  removeAllSourceConnectionsToNote(targetNoteId: string): void {
    try {
      const connectionsToRemove: string[] = [];

      for (const [connectionId] of this.connections.entries()) {
        if (
          connectionId.startsWith("source-") &&
          connectionId.endsWith(`-${targetNoteId}`)
        ) {
          connectionsToRemove.push(connectionId);
        }
      }

      for (const connectionId of connectionsToRemove) {
        const line = this.connections.get(connectionId);
        if (line) {
          try {
            line.remove();
            this.connections.delete(connectionId);
            console.log(`âœ… æº¯æºè¿æ¥çº¿ç§»é™¤æˆåŠŸ: ${connectionId}`);
          } catch (error) {
            console.error(`âŒ ç§»é™¤æº¯æºè¿æ¥çº¿å¤±è´¥: ${connectionId}`, error);
            this.connections.delete(connectionId);
          }
        }
      }
    } catch (error) {
      console.error(`âŒ ç§»é™¤æº¯æºè¿æ¥çº¿å¤±è´¥:`, error);
    }
  }
}
```

#### 6.2 ä¾¿ç­¾æº¯æºæŒ‰é’®å®ç°

```tsx
// src/components/notes/StickyNote.tsx (æº¯æºæŒ‰é’®éƒ¨åˆ†)
// å¤„ç†æº¯æºæŒ‰é’®ç‚¹å‡»
const handleSourceButtonClick = useCallback(
  async (e: React.MouseEvent) => {
    if (isStreaming) return;

    e.stopPropagation();
    e.preventDefault();

    // æ£€æŸ¥æ˜¯å¦æœ‰æº¯æºæ•°æ®
    const hasSourceNoteIds =
      note.sourceNoteIds && note.sourceNoteIds.length > 0;
    const hasSourceNotesContent =
      note.sourceNotesContent && note.sourceNotesContent.length > 0;

    if (!hasSourceNoteIds && !hasSourceNotesContent) {
      return;
    }

    // æ ¹æ®ä¾¿ç­¾ç”Ÿæˆæ¨¡å¼å†³å®šè¡Œä¸º
    if (note.generationMode === "replace" && hasSourceNotesContent) {
      // æ›¿æ¢æ¨¡å¼ï¼šæ‰“å¼€æºä¾¿ç­¾æŸ¥çœ‹å¼¹çª—
      setSourceNotesModalVisible(true);
      return;
    }

    // æ±‡æ€»æ¨¡å¼æˆ–æ²¡æœ‰ç”Ÿæˆæ¨¡å¼æ ‡è¯†ï¼šæ˜¾ç¤º/éšè—è¿æ¥çº¿
    if (!hasSourceNoteIds) {
      return;
    }

    // è·å–å½“å‰æ‰€æœ‰ä¾¿ç­¾ï¼ŒéªŒè¯æºä¾¿ç­¾æ˜¯å¦å­˜åœ¨
    const validSourceNoteIds = note.sourceNoteIds!.filter((sourceId) =>
      allNotes.some((n) => n.id === sourceId)
    );

    if (validSourceNoteIds.length === 0) {
      console.warn("æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„æºä¾¿ç­¾");
      return;
    }

    if (sourceConnectionsVisible) {
      // éšè—æº¯æºè¿æ¥çº¿
      connectionLineManager.removeAllSourceConnectionsToNote(note.id);
      setSourceConnectionsVisible(false);

      // é€šçŸ¥æ‰€æœ‰æºä¾¿ç­¾æ›´æ–°å…¶è¿æ¥çŠ¶æ€
      for (const sourceNoteId of validSourceNoteIds) {
        const event = new CustomEvent("sourceConnectionChanged", {
          detail: { noteId: sourceNoteId },
        });
        window.dispatchEvent(event);
      }
    } else {
      // æ˜¾ç¤ºæº¯æºè¿æ¥çº¿ - åªå°è¯•åˆ›å»ºæœ‰æ•ˆæºä¾¿ç­¾çš„è¿æ¥
      let successCount = 0;
      for (const sourceNoteId of validSourceNoteIds) {
        const success = await connectionLineManager.createSourceConnection(
          sourceNoteId,
          note.id
        );
        if (success) {
          successCount++;
        }
      }

      if (successCount > 0) {
        setSourceConnectionsVisible(true);

        // é€šçŸ¥æ‰€æœ‰æºä¾¿ç­¾æ›´æ–°å…¶è¿æ¥çŠ¶æ€
        for (const sourceNoteId of validSourceNoteIds) {
          const event = new CustomEvent("sourceConnectionChanged", {
            detail: { noteId: sourceNoteId },
          });
          window.dispatchEvent(event);
        }
      } else {
        console.warn("æ²¡æœ‰æˆåŠŸåˆ›å»ºä»»ä½•æº¯æºè¿æ¥çº¿");
      }
    }
  },
  [
    note.id,
    note.sourceNoteIds,
    isStreaming,
    sourceConnectionsVisible,
    allNotes,
    onUpdate,
  ]
);
```

### ç¬¬ä¸ƒæ­¥ï¼šæ•°æ®ç±»å‹å®šä¹‰

#### 7.1 æ ¸å¿ƒç±»å‹å®šä¹‰

```typescript
// src/components/types.ts
import type { JSONContent } from "@tiptap/react";

// ä¾¿ç­¾åŸºç¡€æ¥å£
export interface StickyNote {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  content: JSONContent;
  title?: string;
  color: "yellow" | "blue" | "green" | "pink" | "purple";
  isNew?: boolean;
  zIndex: number;
  isEditing?: boolean;
  isTitleEditing?: boolean;
  createdAt: Date;
  updatedAt: Date;

  // è¿æ¥ç›¸å…³å±æ€§
  isConnected?: boolean;
  connectionIndex?: number;

  // æº¯æºç›¸å…³å±æ€§
  sourceNoteIds?: string[]; // æ±‡æ€»æ¨¡å¼ï¼šæºä¾¿ç­¾IDåˆ—è¡¨
  sourceNotesContent?: SourceNoteContent[]; // æ›¿æ¢æ¨¡å¼ï¼šå®Œæ•´æºä¾¿ç­¾å†…å®¹
  generationMode?: "summary" | "replace"; // ç”Ÿæˆæ¨¡å¼

  // AIç›¸å…³å±æ€§
  thinkingChain?: ThinkingChain; // æ€ç»´é“¾æ•°æ®
  hasThinking?: boolean; // æ˜¯å¦æœ‰æ€ç»´é“¾
}

// æºä¾¿ç­¾å†…å®¹æ¥å£ï¼ˆç”¨äºæ›¿æ¢æ¨¡å¼ï¼‰
export interface SourceNoteContent {
  id: string;
  title?: string;
  content: JSONContent;
  color: string;
  createdAt: Date;
  deletedAt: Date; // è®°å½•åˆ é™¤æ—¶é—´
}

// æ€ç»´é“¾æ¥å£
export interface ThinkingChain {
  steps: ThinkingStep[];
  totalSteps: number;
  summary: string;
}

// æ€ç»´æ­¥éª¤æ¥å£
export interface ThinkingStep {
  id: string;
  content: string;
  stepType: "analysis" | "reasoning" | "conclusion" | "question" | "idea";
  timestamp: Date;
  order: number;
}
```

### ç¬¬å…«æ­¥ï¼šé›†æˆåˆ°ä¸»ç”»å¸ƒ

#### 8.1 ä¸»ç”»å¸ƒç»„ä»¶é›†æˆ

```tsx
// src/components/canvas/InfiniteCanvasNew.tsx (ä¸»è¦é›†æˆéƒ¨åˆ†)
import React, { useCallback, useRef, useEffect } from "react";
import { useConnectionStore } from "../../stores/connectionStore";
import StickyNoteSlots from "./StickyNoteSlots";
import { connectionLineManager } from "../../utils/connectionLineManager";

const InfiniteCanvasNew: React.FC = () => {
  const canvasRef = useRef<HTMLDivElement>(null);

  // è¿æ¥çŠ¶æ€
  const {
    connectedNotes,
    connectionMode,
    isVisible: slotsVisible,
    addConnection,
    removeConnection,
    clearAllConnections,
    setConnectionMode,
    updateConnectionLines,
  } = useConnectionStore();

  // å¤„ç†ä¾¿ç­¾è¿æ¥
  const handleNoteConnect = useCallback(
    (note: StickyNote) => {
      const success = addConnection(note);
      if (success) {
        console.log(`ä¾¿ç­¾ ${note.id} å·²è¿æ¥åˆ°æ’æ§½`);
      } else {
        console.warn(`ä¾¿ç­¾ ${note.id} è¿æ¥å¤±è´¥`);
      }
    },
    [addConnection]
  );

  // ç›‘å¬ç”»å¸ƒå˜åŒ–ï¼Œæ›´æ–°è¿æ¥çº¿ä½ç½®
  useEffect(() => {
    const handleCanvasChange = () => {
      updateConnectionLines();
    };

    // ç›‘å¬ç”»å¸ƒç¼©æ”¾å’Œç§»åŠ¨äº‹ä»¶
    const canvas = canvasRef.current;
    if (canvas) {
      canvas.addEventListener("wheel", handleCanvasChange);
      canvas.addEventListener("mousemove", handleCanvasChange);
    }

    return () => {
      if (canvas) {
        canvas.removeEventListener("wheel", handleCanvasChange);
        canvas.removeEventListener("mousemove", handleCanvasChange);
      }
    };
  }, [updateConnectionLines]);

  return (
    <div className="infinite-canvas-container" ref={canvasRef}>
      {/* ç”»å¸ƒå†…å®¹ */}
      <div className="canvas-content">
        {/* ä¾¿ç­¾æ¸²æŸ“ */}
        {notes.map((note) => (
          <StickyNote
            key={note.id}
            note={note}
            onConnect={handleNoteConnect}
            // ... å…¶ä»–å±æ€§
          />
        ))}
      </div>

      {/* ä¾¿ç­¾æ’æ§½å®¹å™¨ */}
      <StickyNoteSlots
        connectedNotes={connectedNotes}
        connectionMode={connectionMode}
        onModeChange={setConnectionMode}
        onRemoveConnection={removeConnection}
        onClearAllConnections={clearAllConnections}
        visible={slotsVisible}
      />

      {/* AIç”Ÿæˆæ§åˆ¶å°ç­‰å…¶ä»–ç»„ä»¶ */}
    </div>
  );
};

export default InfiniteCanvasNew;
```

## å¤åˆ»è¦ç‚¹æ€»ç»“

### å…³é”®æŠ€æœ¯è¦ç‚¹

1. **Leader Line åº“**ï¼šç”¨äºç»˜åˆ¶è¿æ¥çº¿ï¼Œéœ€è¦åœ¨ public ç›®å½•æ”¾ç½® leader-line.min.js æ–‡ä»¶
2. **Zustand çŠ¶æ€ç®¡ç†**ï¼šç®¡ç†è¿æ¥çŠ¶æ€ï¼Œæ”¯æŒå¤šç»„ä»¶é—´çŠ¶æ€åŒæ­¥
3. **DOM æ“ä½œä¼˜åŒ–**ï¼šä½¿ç”¨ requestAnimationFrame ç¡®ä¿ DOM æ›´æ–°åå†åˆ›å»ºè¿æ¥çº¿
4. **äº‹ä»¶ç³»ç»Ÿ**ï¼šä½¿ç”¨ CustomEvent è¿›è¡Œç»„ä»¶é—´é€šä¿¡
5. **TypeScript ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„ç±»å‹å®šä¹‰ç¡®ä¿ä»£ç è´¨é‡

### æ ·å¼è®¾è®¡è¦ç‚¹

1. **å“åº”å¼è®¾è®¡**ï¼šæ”¯æŒç§»åŠ¨ç«¯å’Œæ¡Œé¢ç«¯
2. **åŠ¨ç”»æ•ˆæœ**ï¼šè¿æ¥çŠ¶æ€çš„è„‰å†²åŠ¨ç”»å’Œæ‚¬åœæ•ˆæœ
3. **è§†è§‰å±‚æ¬¡**ï¼šä½¿ç”¨ z-index å’Œé€æ˜åº¦ç®¡ç†æ˜¾ç¤ºå±‚æ¬¡
4. **ç”¨æˆ·ä½“éªŒ**ï¼šæ¸…æ™°çš„è§†è§‰åé¦ˆå’Œæ“ä½œæç¤º

### åŠŸèƒ½ç‰¹æ€§

1. **åŒæ¨¡å¼æ”¯æŒ**ï¼šæ±‡æ€»æ¨¡å¼ä¿ç•™åŸä¾¿ç­¾ï¼Œæ›¿æ¢æ¨¡å¼åˆ é™¤åŸä¾¿ç­¾
2. **æº¯æºè¿½è¸ª**ï¼šå®Œæ•´è®°å½•ä¾¿ç­¾ç”Ÿæˆæ¥æº
3. **æ€ç»´é“¾æ˜¾ç¤º**ï¼šæ”¯æŒ AI æ€è€ƒè¿‡ç¨‹çš„å¯è§†åŒ–
4. **å®æ—¶è¿æ¥çº¿**ï¼šåŠ¨æ€æ›´æ–°è¿æ¥çº¿ä½ç½®

### éƒ¨ç½²æ³¨æ„äº‹é¡¹

1. ç¡®ä¿ Leader Line åº“æ­£ç¡®åŠ è½½
2. é…ç½® AI æœåŠ¡æ¥å£
3. è®¾ç½® IndexedDB å­˜å‚¨
4. ä¼˜åŒ–æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨

é€šè¿‡ä»¥ä¸Šæ­¥éª¤ï¼Œæ‚¨å¯ä»¥å®Œæ•´å¤åˆ»ä¾¿ç­¾é“¾æ¥æ’æ§½æ±‡æ€»åŠŸèƒ½ï¼Œå®ç°ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€ç”¨æˆ·ä½“éªŒè‰¯å¥½çš„ä¾¿ç­¾è¿æ¥ç³»ç»Ÿã€‚
