# 便签链接插槽汇总功能复刻指南

## 概述

本指南详细介绍了无限便签项目中的便签链接插槽汇总功能的实现原理和复刻步骤。该功能允许用户将多个便签连接到插槽中，然后通过 AI 生成汇总内容，支持两种生成模式：汇总模式和替换模式。

## 核心功能架构

### 1. 功能组成

- **便签连接点**：每个便签左下角的连接点，用于建立连接
- **便签插槽容器**：底部的插槽容器，显示已连接的便签
- **连接线管理**：可视化连接线，连接便签与插槽
- **AI 生成模式**：支持汇总模式和替换模式的 AI 内容生成
- **溯源追踪**：记录便签的生成来源和依赖关系

### 2. 技术栈

- **React 18** + **TypeScript**：前端框架和类型系统
- **Zustand**：状态管理
- **Leader Line**：连接线绘制库
- **Ant Design**：UI 组件库
- **IndexedDB**：本地数据存储

## 详细实现步骤

### 第一步：便签连接点实现

#### 1.1 连接点组件结构

在便签组件中添加连接点：

```tsx
// src/components/notes/StickyNote.tsx
{
  /* 连接点 - 始终显示，编辑状态下隐藏但保留在DOM中 */
}
{
  !isStreaming && (
    <div
      className={`connection-point ${isConnected ? "connected" : ""} ${
        note.sourceNoteIds && note.sourceNoteIds.length > 0 ? "has-source" : ""
      } ${sourceConnectionsVisible ? "source-active" : ""} ${
        isSourceConnected ? "source-connected" : ""
      } ${isBeingSourceConnected ? "being-source-connected" : ""} ${
        note.isEditing ? "editing-hidden" : ""
      }`}
      onClick={note.isEditing ? undefined : handleConnectionClick}
      title={
        note.isEditing
          ? ""
          : isConnected
          ? "已连接到插槽"
          : isSourceConnected
          ? "作为源便签被其他便签引用"
          : onConnect
          ? "点击连接到插槽"
          : "点击添加到连接插槽"
      }
      style={{
        pointerEvents: note.isEditing ? "none" : "auto",
      }}
    >
      <div className="connection-dot"></div>
    </div>
  );
}
```

#### 1.2 连接点样式

```css
/* src/components/notes/StickyNote.css */
.connection-point {
  position: absolute;
  bottom: 8px; /* 调整到便签内部，距离底部8px */
  left: 8px; /* 调整到便签内部，距离左边8px */
  width: 18px; /* 与插槽尺寸统一 */
  height: 18px; /* 与插槽尺寸统一 */
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(22, 119, 255, 0.2);
  cursor: pointer;
  transition: all 0.2s ease;
  opacity: 0; /* 默认隐藏，悬停时显示 */
  display: flex;
  align-items: center;
  justify-content: center;
}

/* 便签悬停时显示连接点 */
.sticky-note:hover .connection-point {
  opacity: 1;
}

/* 连接点内部的圆点 */
.connection-dot {
  width: 15px;
  height: 15px;
  border-radius: 50%;
  background: #1677ff;
  border: 1px solid rgba(255, 255, 255, 1);
  transition: all 0.2s ease;
  margin: auto;
}

/* 已连接状态的连接点 */
.connection-point.connected {
  opacity: 1; /* 已连接时始终显示 */
}

.connection-point.connected .connection-dot {
  background: #52c41a; /* 绿色表示已连接 */
  border-color: rgba(255, 255, 255, 1);
  animation: connectedPulse 4s ease-in-out infinite;
}

/* 连接状态脉冲动画 */
@keyframes connectedPulse {
  0%,
  100% {
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12), 0 0 0 0 rgba(82, 196, 26, 0.2);
  }
  50% {
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12), 0 0 0 3px rgba(82, 196, 26, 0.15);
  }
}
```

### 第二步：便签插槽容器实现

#### 2.1 插槽容器组件

```tsx
// src/components/canvas/StickyNoteSlots.tsx
import React from "react";
import { Tooltip } from "antd";
import type { StickyNote } from "../types";
import { connectionUtils } from "../../stores/connectionStore";
import "./StickyNoteSlots.css";

// 连接模式枚举
export const ConnectionMode = {
  SUMMARY: "summary", // 汇总模式：保留原始便签，并自动将它们连接到新便签
  REPLACE: "replace", // 替换模式：删除原始便签，只保留新生成的便签
} as const;

// 插槽组件属性接口
interface StickyNoteSlotsProps {
  connectedNotes: StickyNote[]; // 已连接的便签列表
  connectionMode: (typeof ConnectionMode)[keyof typeof ConnectionMode]; // 连接模式
  onModeChange: (
    mode: (typeof ConnectionMode)[keyof typeof ConnectionMode]
  ) => void; // 模式切换回调
  onRemoveConnection: (noteId: string) => void; // 移除连接回调
  onClearAllConnections: () => void; // 清空所有连接回调
  visible?: boolean; // 是否显示插槽容器
}

const StickyNoteSlots: React.FC<StickyNoteSlotsProps> = ({
  connectedNotes,
  connectionMode,
  onModeChange,
  onRemoveConnection,
  onClearAllConnections,
  visible = true,
}) => {
  return (
    <div
      className={`slots-container ${
        visible && connectedNotes.length > 0 ? "visible" : ""
      }`}
      id="slots-container"
    >
      {/* 插槽列表 */}
      <div className="slots-list" id="slots-list">
        {connectedNotes.length === 0 ? (
          <div className="empty-slots">
            <div className="empty-slot-circle">
              <span className="empty-slot-icon">○</span>
            </div>
            <div className="empty-text-container">
              <span className="empty-text">暂无连接的便签</span>
              <span className="empty-hint">
                悬停便签并点击左下角{" "}
                <span className="connection-dot-demo">●</span> 连接点来建立连接
              </span>
            </div>
          </div>
        ) : (
          connectedNotes.map((note, index) => (
            <div
              key={note.id}
              className="note-slot connected"
              data-note-id={note.id}
              data-index={index + 1}
              title={(() => {
                const displayedContent =
                  connectionUtils.getDisplayedNoteContent(note);
                return `${
                  note.title || "无标题便签"
                }: ${displayedContent.substring(0, 50)}${
                  displayedContent.length > 50 ? "..." : ""
                }`;
              })()}
            >
              {/* 圆形插槽 */}
              <div className="slot-circle">
                <span className="slot-index">{index + 1}</span>
              </div>
              {/* 删除按钮 - 位于圆形右上角 */}
              <div
                className="slot-remove"
                onClick={() => onRemoveConnection(note.id)}
                title="移除连接"
              >
                ×
              </div>
            </div>
          ))
        )}
      </div>

      {/* 连接模式切换器 */}
      <Tooltip
        title={<div dangerouslySetInnerHTML={{ __html: getModeTooltip() }} />}
        placement="top"
        arrow={false}
        mouseEnterDelay={0.5}
      >
        <div className="mode-selector" id="connection-mode-selector">
          <button
            className={`mode-button ${
              connectionMode === ConnectionMode.SUMMARY ? "active" : ""
            }`}
            onClick={() => onModeChange(ConnectionMode.SUMMARY)}
          >
            汇总
          </button>
          <button
            className={`mode-button ${
              connectionMode === ConnectionMode.REPLACE ? "active" : ""
            }`}
            onClick={() => onModeChange(ConnectionMode.REPLACE)}
          >
            替换
          </button>
        </div>
      </Tooltip>
    </div>
  );
};

export default StickyNoteSlots;
```

#### 2.2 插槽容器样式

```css
/* src/components/canvas/StickyNoteSlots.css */
.slots-container {
  position: fixed;
  bottom: 90px; /* 位于控制台上方 */
  left: 50%;
  transform: translateX(-50%);
  z-index: 98; /* 略低于控制台 */
  max-width: 480px;
  width: 75%;
  min-width: 320px;
  margin-left: auto;
  margin-right: auto;

  /* 容器样式 - 实色背景提高性能 */
  background: #ffffff;
  border-radius: 16px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08), 0 1px 3px rgba(0, 0, 0, 0.05);
  border: 1px solid rgba(22, 119, 255, 0.08);
  transition: opacity 0.2s ease-out;
  overflow: hidden;
  /* 默认隐藏，只有在有连接时才显示 */
  opacity: 0;
  visibility: hidden;
  display: none;
}

.slots-container.visible {
  opacity: 1;
  visibility: visible;
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 6px 10px;
  height: 44px;
  box-sizing: border-box;
}

/* 插槽列表容器 - 横排布局 */
.slots-list {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 8px;
  overflow-x: auto;
  overflow-y: hidden;
  flex: 1;
  min-width: 0;
  padding: 0 4px;
  height: 100%;

  /* 隐藏滚动条但保持滚动功能 */
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.slots-list::-webkit-scrollbar {
  display: none;
}

/* 便签插槽样式 - 圆形设计 */
.note-slot {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.2s ease;
  cursor: pointer;
}

/* 圆形插槽样式 */
.slot-circle {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: rgba(22, 119, 255, 0.1);
  border: 1px solid rgba(22, 119, 255, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  position: relative;
  flex-shrink: 0;
}

.note-slot.connected .slot-circle {
  background: rgba(22, 119, 255, 0.2);
  border-color: #1677ff;
  box-shadow: 0 1px 4px rgba(22, 119, 255, 0.2);
  animation: slotConnectedPulse 4s ease-in-out infinite;
}

/* 连接状态的脉冲动画 */
@keyframes slotConnectedPulse {
  0%,
  100% {
    box-shadow: 0 1px 4px rgba(22, 119, 255, 0.2), 0 0 0 0 rgba(22, 119, 255, 0.3);
  }
  50% {
    box-shadow: 0 1px 5px rgba(22, 119, 255, 0.25), 0 0 0 1px rgba(22, 119, 255, 0.15);
  }
}

/* 插槽索引数字 */
.slot-index {
  font-size: 9px;
  font-weight: 600;
  color: #1677ff;
  user-select: none;
}

/* 移除按钮 - 位于圆形右上角 */
.slot-remove {
  position: absolute;
  top: -2px;
  right: -2px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: rgba(255, 77, 79, 0.9);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 10;
  border: 1px solid white;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.slot-remove:hover {
  background: #ff4d4f;
  transform: scale(1.15);
  box-shadow: 0 1px 4px rgba(255, 77, 79, 0.4);
}

/* 模式切换器样式 */
.mode-selector {
  display: flex;
  align-items: center;
  background-color: rgba(22, 119, 255, 0.08);
  border-radius: 6px;
  padding: 2px;
  margin-right: 12px;
  flex-shrink: 0;
  border: 1px solid rgba(22, 119, 255, 0.15);
}

.mode-button {
  background-color: transparent;
  border: none;
  color: rgba(22, 119, 255, 0.7);
  padding: 3px 8px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 10px;
  font-weight: 500;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.mode-button.active {
  background-color: #1677ff;
  color: white;
  box-shadow: 0 1px 3px rgba(22, 119, 255, 0.3);
}

.mode-button:not(.active):hover {
  background-color: rgba(22, 119, 255, 0.1);
  color: #1677ff;
}
```

### 第三步：连接状态管理

#### 3.1 连接状态 Store

```typescript
// src/stores/connectionStore.ts
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import type { StickyNote } from "../components/types";
import { ConnectionMode } from "../components/canvas/StickyNoteSlots";
import { connectionLineManager } from "../utils/connectionLineManager";

// 连接模式类型
type ConnectionModeType = (typeof ConnectionMode)[keyof typeof ConnectionMode];

// 连接状态接口
export interface ConnectionState {
  // 连接数据
  connectedNotes: StickyNote[]; // 已连接的便签列表
  connectionMode: ConnectionModeType; // 连接模式
  maxConnections: number; // 最大连接数量

  // 状态标识
  isVisible: boolean; // 插槽容器是否可见
}

// 连接操作接口
export interface ConnectionActions {
  // 连接操作
  addConnection: (note: StickyNote) => boolean;
  removeConnection: (noteId: string) => void;
  clearAllConnections: () => void;

  // 模式管理
  setConnectionMode: (mode: ConnectionModeType) => void;

  // 可见性管理
  setVisible: (visible: boolean) => void;

  // 工具方法
  isNoteConnected: (noteId: string) => boolean;
  getConnectionIndex: (noteId: string) => number;
  canAddConnection: () => boolean;

  // 连接线管理
  updateConnectionLines: (immediate?: boolean) => void;
}

// 创建连接Store
export const useConnectionStore = create<ConnectionState & ConnectionActions>()(
  devtools(
    (set, get) => ({
      // 初始状态
      connectedNotes: [],
      connectionMode: ConnectionMode.SUMMARY, // 默认汇总模式
      maxConnections: 10, // 最大连接10个便签
      isVisible: false,

      // 连接操作
      addConnection: (note: StickyNote) => {
        const state = get();

        // 检查是否已连接
        if (state.isNoteConnected(note.id)) {
          return false;
        }

        // 检查是否超过最大连接数
        if (!state.canAddConnection()) {
          return false;
        }

        // 计算新的连接索引
        const newIndex = state.connectedNotes.length + 1;

        // 添加连接
        const updatedNote = {
          ...note,
          isConnected: true,
          connectionIndex: newIndex,
        };

        set({
          connectedNotes: [...state.connectedNotes, updatedNote],
          isVisible: true, // 有连接时显示插槽容器
        });

        // 使用requestAnimationFrame确保DOM已更新，减少延迟
        requestAnimationFrame(async () => {
          await connectionLineManager.createConnection(updatedNote, newIndex);
        });

        return true;
      },

      removeConnection: (noteId: string) => {
        const state = get();

        // 移除连接线
        connectionLineManager.removeConnection(noteId);

        const updatedNotes = state.connectedNotes.filter(
          (note) => note.id !== noteId
        );

        // 重新分配连接索引
        const reindexedNotes = updatedNotes.map((note, index) => ({
          ...note,
          connectionIndex: index + 1,
        }));

        set({
          connectedNotes: reindexedNotes,
          isVisible: reindexedNotes.length > 0, // 没有连接时隐藏插槽容器
        });

        // 使用requestAnimationFrame重新创建剩余连接线，减少延迟
        requestAnimationFrame(async () => {
          for (const note of reindexedNotes) {
            await connectionLineManager.createConnection(
              note,
              note.connectionIndex!
            );
          }
        });
      },

      clearAllConnections: () => {
        try {
          // 获取当前状态
          const state = get();
          const noteIds = state.connectedNotes.map((note) => note.id);

          console.log(
            "🔗 ConnectionStore: 清空所有连接，当前连接数:",
            noteIds.length
          );

          // 清空所有连接线（只清空普通连接线，保留溯源连接线）
          connectionLineManager.clearAllConnections();

          // 重置状态
          set({
            connectedNotes: [], // 清空连接的便签列表
            isVisible: false, // 隐藏插槽容器
          });

          console.log("✅ ConnectionStore: 连接状态已清空");
        } catch (error) {
          console.error("❌ ConnectionStore: 清空连接失败:", error);
          // 即使出错也尝试重置状态
          set({
            connectedNotes: [],
            isVisible: false,
          });
        }
      },

      // 模式管理
      setConnectionMode: (mode: ConnectionModeType) => {
        set({ connectionMode: mode });
      },

      // 可见性管理
      setVisible: (visible: boolean) => {
        set({ isVisible: visible });
      },

      // 工具方法
      isNoteConnected: (noteId: string) => {
        const state = get();
        return state.connectedNotes.some((note) => note.id === noteId);
      },

      getConnectionIndex: (noteId: string) => {
        const state = get();
        const note = state.connectedNotes.find((note) => note.id === noteId);
        return note?.connectionIndex || -1;
      },

      canAddConnection: () => {
        const state = get();
        return state.connectedNotes.length < state.maxConnections;
      },

      // 优化后的连接线管理 - 统一接口，支持立即更新选项
      updateConnectionLines: (immediate: boolean = false) => {
        if (immediate) {
          connectionLineManager.updateConnectionPositionsImmediate();
        } else {
          connectionLineManager.updateConnectionPositions();
        }
      },
    }),
    {
      name: "connection-store", // DevTools中的名称
    }
  )
);
```

### 第四步：连接线管理器

#### 4.1 Leader Line 加载器

```typescript
// src/utils/leaderLineLoader.ts
let LeaderLineClass: any = null;

// 加载 Leader Line
export const loadLeaderLine = async (): Promise<any> => {
  // 如果已经有缓存的实例，直接返回
  if (LeaderLineClass) {
    return LeaderLineClass;
  }

  // 检查是否在浏览器环境中
  if (typeof window === "undefined" || typeof document === "undefined") {
    throw new Error("Leader Line 需要浏览器环境");
  }

  // 检查全局变量（可能已经通过 script 标签加载）
  if ((window as any).LeaderLine) {
    LeaderLineClass = (window as any).LeaderLine;
    return LeaderLineClass;
  }

  // 如果没有预加载，则动态加载
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = "/leader-line.min.js";

    const timeout = setTimeout(() => {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
      reject(new Error("Leader Line 加载超时"));
    }, 8000); // 8秒超时

    script.onload = () => {
      clearTimeout(timeout);
      if ((window as any).LeaderLine) {
        LeaderLineClass = (window as any).LeaderLine;
        resolve(LeaderLineClass);
      } else {
        reject(new Error("Leader Line 加载失败：未找到全局变量"));
      }
    };

    script.onerror = () => {
      clearTimeout(timeout);
      reject(new Error("Leader Line 脚本加载失败"));
    };

    document.head.appendChild(script);
  });
};

// 检查 Leader Line 是否已加载
export const isLeaderLineLoaded = (): boolean => {
  return (
    LeaderLineClass !== null ||
    (typeof window !== "undefined" && !!(window as any).LeaderLine)
  );
};
```

#### 4.2 连接线管理器核心实现

```typescript
// src/utils/connectionLineManager.ts
import { loadLeaderLine } from "./leaderLineLoader";
import type { StickyNote } from "../components/types";

class ConnectionLineManager {
  private connections = new Map<string, any>(); // 存储连接线实例
  private updateTimeout: NodeJS.Timeout | null = null;

  // 生成连接ID
  private getConnectionId(noteId: string, slotIndex: number): string {
    return `connection-${noteId}-${slotIndex}`;
  }

  // 创建连接线
  async createConnection(
    note: StickyNote,
    slotIndex: number
  ): Promise<boolean> {
    try {
      const connectionId = this.getConnectionId(note.id, slotIndex);

      // 检查是否已存在连接
      if (this.connections.has(connectionId)) {
        console.warn(`连接线 ${connectionId} 已存在`);
        return false;
      }

      // 使用requestAnimationFrame等待DOM更新，减少延迟
      await new Promise((resolve) => requestAnimationFrame(resolve));

      // 获取便签连接点元素 - 使用连接点容器作为连接目标
      const noteElement = document.querySelector(`[data-note-id="${note.id}"]`);
      const connectionPoint = noteElement?.querySelector(
        ".connection-point"
      ) as HTMLElement;

      if (!connectionPoint) {
        console.error(`未找到便签 ${note.id} 的连接点`);
        return false;
      }

      // 获取插槽元素
      const slotElement = document.querySelector(
        `[data-note-id="${note.id}"][data-index="${slotIndex}"]`
      ) as HTMLElement;

      if (!slotElement) {
        console.error(`未找到插槽 ${slotIndex}`);
        return false;
      }

      // 加载Leader Line
      const LeaderLineClass = await loadLeaderLine();

      // 强制刷新元素位置
      connectionPoint.getBoundingClientRect();
      slotElement.getBoundingClientRect();

      // 创建Leader Line连接线 - 使用贝塞尔曲线，无端点圆点
      const line = new LeaderLineClass(connectionPoint, slotElement, {
        color: "#1677ff", // 蓝色连接线
        size: 4, // 线条粗细
        path: "fluid", // 使用流畅的贝塞尔曲线
        startSocket: "auto", // 让Leader Line自动选择最佳连接点
        endSocket: "auto", // 让Leader Line自动选择最佳连接点
        startSocketGravity: "auto", // 使用auto让Leader Line自动计算
        endSocketGravity: "auto", // 使用auto让Leader Line自动计算
        startPlug: "behind", // 隐藏起始点圆点
        endPlug: "behind", // 隐藏结束点圆点
        outline: true, // 启用轮廓
        outlineColor: "rgba(255, 255, 255, 0.8)", // 白色轮廓
        outlineSize: 1.2, // 轮廓大小
        animate: {
          // 连接动画
          duration: 400,
          timing: "ease-in-out",
        },
      });

      // 存储连接线实例
      this.connections.set(connectionId, line);

      console.log(`✅ 连接线创建成功: ${connectionId}`);
      return true;
    } catch (error) {
      console.error(`❌ 创建连接线失败:`, error);
      return false;
    }
  }

  // 移除连接线
  removeConnection(noteId: string): void {
    try {
      // 查找并移除所有相关的连接线
      const connectionsToRemove: string[] = [];

      for (const [connectionId, line] of this.connections.entries()) {
        if (connectionId.includes(noteId)) {
          connectionsToRemove.push(connectionId);
        }
      }

      // 移除找到的连接线
      for (const connectionId of connectionsToRemove) {
        const line = this.connections.get(connectionId);
        if (line) {
          try {
            line.remove();
            this.connections.delete(connectionId);
            console.log(`✅ 连接线移除成功: ${connectionId}`);
          } catch (error) {
            console.error(`❌ 移除连接线失败: ${connectionId}`, error);
            // 即使移除失败，也要从Map中删除
            this.connections.delete(connectionId);
          }
        }
      }
    } catch (error) {
      console.error(`❌ 移除连接线失败:`, error);
    }
  }

  // 清空所有连接线
  clearAllConnections(): void {
    try {
      console.log(
        `🔗 ConnectionLineManager: 开始清空所有连接线，当前连接数: ${this.connections.size}`
      );

      // 只清空普通连接线，保留溯源连接线
      const connectionsToRemove: string[] = [];

      for (const [connectionId] of this.connections.entries()) {
        // 只清空以 "connection-" 开头的普通连接线
        if (connectionId.startsWith("connection-")) {
          connectionsToRemove.push(connectionId);
        }
      }

      // 移除普通连接线
      for (const connectionId of connectionsToRemove) {
        const line = this.connections.get(connectionId);
        if (line) {
          try {
            line.remove();
            this.connections.delete(connectionId);
          } catch (error) {
            console.error(`❌ 移除连接线失败: ${connectionId}`, error);
            // 即使移除失败，也要从Map中删除
            this.connections.delete(connectionId);
          }
        }
      }

      console.log(
        `✅ ConnectionLineManager: 普通连接线清空完成，移除数量: ${connectionsToRemove.length}`
      );
    } catch (error) {
      console.error(`❌ ConnectionLineManager: 清空连接线失败:`, error);
    }
  }

  // 更新连接线位置（防抖版本）
  updateConnectionPositions(): void {
    if (this.updateTimeout) {
      clearTimeout(this.updateTimeout);
    }

    this.updateTimeout = setTimeout(() => {
      this.updateConnectionPositionsImmediate();
    }, 100); // 100ms防抖
  }

  // 立即更新连接线位置
  updateConnectionPositionsImmediate(): void {
    try {
      for (const [connectionId, line] of this.connections.entries()) {
        if (line && typeof line.position === "function") {
          try {
            line.position();
          } catch (error) {
            console.warn(`更新连接线位置失败: ${connectionId}`, error);
          }
        }
      }
    } catch (error) {
      console.error("更新连接线位置失败:", error);
    }
  }
}

// 导出单例实例
export const connectionLineManager = new ConnectionLineManager();
```

### 第五步：AI 生成与便签会中生成模式

#### 5.1 AI 服务核心实现

```typescript
// src/services/ai/aiService.ts
import type { JSONContent } from "@tiptap/react";
import ContentFormatService from "../contentFormatService";

// AI便签数据接口
interface StickyNoteData {
  title: string;
  content: JSONContent;
  color?: string;
  tags?: string[];
  thinkingChain?: ThinkingChain;
  hasThinking?: boolean;
}

// 思维链接口
interface ThinkingChain {
  steps: ThinkingStep[];
  totalSteps: number;
  summary: string;
}

interface ThinkingStep {
  id: string;
  content: string;
  stepType: "analysis" | "reasoning" | "conclusion" | "question" | "idea";
  timestamp: Date;
  order: number;
}

class AIService {
  // 智能解析AI回复，支持思维链
  parseResponseIntelligently(
    response: string,
    originalPrompt: string,
    showThinkingMode: boolean = false
  ): { success: boolean; notes: StickyNoteData[]; error?: string } {
    try {
      // 检测思维链标签
      const thinkingMatch = response.match(/<thinking>([\s\S]*?)<\/thinking>/i);
      const thinkMatch = response.match(/<think>([\s\S]*?)<\/think>/i);

      let thinkingContent = thinkingMatch?.[1] || thinkMatch?.[1];
      let thinkingChain: ThinkingChain | undefined;

      // 如果有思维链内容且开启显示模式，解析思维链
      if (thinkingContent && showThinkingMode) {
        thinkingChain = this.parseThinkingChain(thinkingContent.trim());
      }

      // 提取最终答案（移除思维链标签）
      let cleanContent = response
        .replace(/<thinking>[\s\S]*?<\/thinking>/gi, "")
        .replace(/<think>[\s\S]*?<\/think>/gi, "")
        .trim();

      // 如果内容为空，使用原始响应
      if (!cleanContent) {
        cleanContent = response;
      }

      const note: StickyNoteData = {
        title: this.generateTitleFromContent(cleanContent),
        content: ContentFormatService.markdownToJson(cleanContent),
        thinkingChain,
        hasThinking: !!thinkingChain,
      };

      return { success: true, notes: [note] };
    } catch (error) {
      console.error("❌ 智能解析失败:", error);
      return { success: false, error: "解析AI回复失败" };
    }
  }

  // 解析思维链
  private parseThinkingChain(thinkingContent: string): ThinkingChain {
    // 按段落分割思维内容
    const paragraphs = thinkingContent
      .split(/\n\s*\n/)
      .map((p) => p.trim())
      .filter((p) => p.length > 0);

    // 步骤类型识别规则
    const stepTypeRules = [
      {
        type: "analysis" as const,
        keywords: ["分析", "观察", "发现", "注意到", "可以看出"],
      },
      {
        type: "reasoning" as const,
        keywords: ["因为", "所以", "推理", "逻辑", "基于", "考虑到"],
      },
      {
        type: "conclusion" as const,
        keywords: ["结论", "总结", "因此", "综上", "最终"],
      },
      {
        type: "question" as const,
        keywords: ["问题", "疑问", "是否", "如何", "为什么"],
      },
      {
        type: "idea" as const,
        keywords: ["想法", "建议", "方案", "策略", "方法"],
      },
    ];

    const steps = paragraphs.map((paragraph, index) => {
      // 使用优化的规则匹配步骤类型
      let stepType:
        | "analysis"
        | "reasoning"
        | "conclusion"
        | "question"
        | "idea" = "reasoning";

      for (const rule of stepTypeRules) {
        if (rule.keywords.some((keyword) => paragraph.includes(keyword))) {
          stepType = rule.type;
          break;
        }
      }

      return {
        id: `step-${Date.now()}-${index}-${Math.random()
          .toString(36)
          .substring(2, 8)}`,
        content: paragraph,
        stepType,
        timestamp: new Date(Date.now() + index * 100),
        order: index + 1,
      };
    });

    return {
      steps,
      totalSteps: steps.length,
      summary: `AI进行了${steps.length}步思考，包含${
        steps.filter((s) => s.stepType === "analysis").length
      }个分析步骤和${
        steps.filter((s) => s.stepType === "reasoning").length
      }个推理步骤。`,
    };
  }

  // 从内容生成标题
  private generateTitleFromContent(content: string): string {
    if (!content || content.trim().length === 0) {
      return "AI便签";
    }

    // 清理内容，移除Markdown标记
    const cleanContent = content
      .replace(/[#*`_~\[\]()]/g, "")
      .replace(/\s+/g, " ")
      .trim();

    // 取前30个字符作为标题
    if (cleanContent.length > 30) {
      return cleanContent.substring(0, 30) + "...";
    }

    return cleanContent || "AI便签";
  }
}

export default new AIService();
```

#### 5.2 便签会中生成模式实现

```typescript
// src/components/canvas/InfiniteCanvasNew.tsx (AI生成部分)
const handleAIGenerate = async (prompt: string) => {
  try {
    // 开始AI生成状态
    startGeneration();

    // 如果有连接的便签，将其内容包含在提示中
    let finalPrompt = prompt;
    if (connectedNotes.length > 0) {
      const { prompt: generatedPrompt } =
        connectionUtils.generateAIPromptWithConnections(prompt, connectedNotes);
      finalPrompt = generatedPrompt;
    }

    // 计算便签创建位置（画布中心附近）
    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) {
      throw new Error("无法获取画布位置");
    }

    const centerX = rect.width / 2;
    const centerY = rect.height / 2;

    // 添加随机偏移，避免便签重叠
    const randomRange = 150;
    const distributedScreenX =
      centerX + (Math.random() * randomRange - randomRange / 2);
    const distributedScreenY =
      centerY + (Math.random() * randomRange - randomRange / 2);

    // 转换为逻辑坐标
    const logicalX =
      (distributedScreenX - canvasState.offsetX) / canvasState.scale;
    const logicalY =
      (distributedScreenY - canvasState.offsetY) / canvasState.scale;

    // 准备溯源数据
    let sourceNoteIds: string[] | undefined;
    let sourceNotesContent: SourceNoteContent[] | undefined;
    let generationMode: "summary" | "replace" | undefined;

    if (connectedNotes.length > 0) {
      generationMode = connectionMode;

      if (connectionMode === "summary") {
        // 汇总模式：只记录源便签ID
        sourceNoteIds = connectedNotes.map((note) => note.id);
      } else if (connectionMode === "replace") {
        // 替换模式：保存完整的原始便签内容，保持JSON格式
        sourceNotesContent = connectedNotes.map((note) => ({
          id: note.id,
          title: note.title,
          content: note.content, // 保持JSONContent格式
          color: note.color,
          createdAt: note.createdAt,
          deletedAt: new Date(), // 记录删除时间
        }));
        // 立即删除旧便签并清空连接，防止新便签继承状态
        connectedNotes.forEach((note) => deleteNote(note.id));
        clearAllConnections();
      }
    }

    // 生成随机颜色
    const colors: Array<StickyNoteType["color"]> = [
      "yellow",
      "blue",
      "green",
      "pink",
      "purple",
    ];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];

    // 生成便签标题：使用用户的prompt，限制长度避免过长
    const generateTitleFromPrompt = (prompt: string): string => {
      if (!prompt || prompt.trim().length === 0) {
        return "AI便签";
      }

      const cleanPrompt = prompt.trim().replace(/\s+/g, " ");

      if (cleanPrompt.length > 30) {
        return cleanPrompt.substring(0, 30) + "...";
      }

      return cleanPrompt;
    };

    const tempNote: StickyNoteType = {
      id: `ai-note-${Date.now()}-${Math.random()
        .toString(36)
        .substring(2, 11)}`,
      x: logicalX,
      y: logicalY,
      width: 380, // AI便签默认宽度
      height: 330, // AI便签默认高度
      content: ContentFormatService.markdownToJson(""),
      title: generateTitleFromPrompt(prompt),
      color: randomColor,
      isNew: false,
      zIndex: maxZ + 1,
      isEditing: false,
      isTitleEditing: false,
      createdAt: new Date(),
      updatedAt: new Date(),
      // 溯源相关属性
      sourceNoteIds,
      sourceNotesContent,
      generationMode,
    };

    // 添加临时便签到数据库，指定为AI便签类型
    const addedNote = await addNote(tempNote, "ai");

    // 开始流式生成
    startStreamingNote(addedNote.id, addedNote);

    // 调用AI服务进行流式生成
    await aiService.generateStreamingContent(finalPrompt, {
      onChunk: (chunk) => {
        // 更新流式内容
        updateStreamingContent(addedNote.id, chunk);
      },
      onComplete: () => {
        // 完成生成
        finishGeneration();
      },
      onNoteComplete: async (_, noteData) => {
        // 一次性更新所有数据，避免多次数据库操作
        const updateData: any = {
          content: noteData.content, // 最终内容
          color: tempNote.color, // 保持临时便签的颜色
          title: tempNote.title, // 保持用户prompt作为标题，不被AI覆盖
          updatedAt: new Date(),
        };

        // 如果有思维链数据，添加到更新中
        if (noteData.thinkingChain) {
          updateData.thinkingChain = noteData.thinkingChain;
          updateData.hasThinking = true;
        }

        // 直接更新便签数据
        await updateStickyNote(addedNote.id, updateData);

        // 清理流式状态
        cancelStreamingNote(addedNote.id);
      },
      onError: (error) => {
        console.error("AI生成失败:", error);
        cancelGeneration();
        // 删除失败的便签
        deleteNote(addedNote.id);
      },
    });
  } catch (error) {
    console.error("AI生成过程失败:", error);
    cancelGeneration();
  }
};
```

### 第六步：溯源连接线实现

#### 6.1 溯源连接线管理

```typescript
// src/utils/connectionLineManager.ts (溯源连接线部分)
class ConnectionLineManager {
  // 生成溯源连接ID
  private getSourceConnectionId(
    sourceNoteId: string,
    targetNoteId: string
  ): string {
    return `source-${sourceNoteId}-${targetNoteId}`;
  }

  // 创建溯源连接线
  async createSourceConnection(
    sourceNoteId: string,
    targetNoteId: string
  ): Promise<boolean> {
    try {
      const connectionId = this.getSourceConnectionId(
        sourceNoteId,
        targetNoteId
      );

      // 检查是否已存在连接
      if (this.connections.has(connectionId)) {
        console.warn(`溯源连接线 ${connectionId} 已存在`);
        return false;
      }

      // 等待DOM更新
      await new Promise((resolve) => requestAnimationFrame(resolve));

      // 获取源便签的连接点
      const sourceNoteElement = document.querySelector(
        `[data-note-id="${sourceNoteId}"]`
      );
      const sourceConnectionPoint = sourceNoteElement?.querySelector(
        ".connection-point"
      ) as HTMLElement;

      if (!sourceConnectionPoint) {
        console.error(`未找到源便签 ${sourceNoteId} 的连接点`);
        return false;
      }

      // 获取目标便签的连接点
      const targetNoteElement = document.querySelector(
        `[data-note-id="${targetNoteId}"]`
      );
      const targetConnectionPoint = targetNoteElement?.querySelector(
        ".connection-point"
      ) as HTMLElement;

      if (!targetConnectionPoint) {
        console.error(`未找到目标便签 ${targetNoteId} 的连接点`);
        return false;
      }

      // 加载Leader Line
      const LeaderLineClass = await loadLeaderLine();

      // 强制刷新元素位置
      sourceConnectionPoint.getBoundingClientRect();
      targetConnectionPoint.getBoundingClientRect();

      // 创建溯源连接线 - 使用不同的样式
      const line = new LeaderLineClass(
        sourceConnectionPoint,
        targetConnectionPoint,
        {
          color: "#fa8c16", // 橙色连接线，与溯源连接点颜色一致
          size: 3, // 稍细一些
          path: "fluid", // 使用流畅的贝塞尔曲线
          startSocket: "auto",
          endSocket: "auto",
          startSocketGravity: "auto",
          endSocketGravity: "auto",
          startPlug: "behind", // 隐藏起始点圆点
          endPlug: "behind", // 隐藏结束点圆点
          outline: true, // 启用轮廓
          outlineColor: "rgba(255, 255, 255, 0.9)", // 白色轮廓
          outlineSize: 1, // 轮廓大小
          dash: { len: 8, gap: 4 }, // 虚线样式，区分普通连接线
          animate: {
            // 连接动画
            duration: 500,
            timing: "ease-in-out",
          },
        }
      );

      // 存储连接线实例
      this.connections.set(connectionId, line);

      console.log(`✅ 溯源连接线创建成功: ${connectionId}`);
      return true;
    } catch (error) {
      console.error(`❌ 创建溯源连接线失败:`, error);
      return false;
    }
  }

  // 移除所有指向特定便签的溯源连接线
  removeAllSourceConnectionsToNote(targetNoteId: string): void {
    try {
      const connectionsToRemove: string[] = [];

      for (const [connectionId] of this.connections.entries()) {
        if (
          connectionId.startsWith("source-") &&
          connectionId.endsWith(`-${targetNoteId}`)
        ) {
          connectionsToRemove.push(connectionId);
        }
      }

      for (const connectionId of connectionsToRemove) {
        const line = this.connections.get(connectionId);
        if (line) {
          try {
            line.remove();
            this.connections.delete(connectionId);
            console.log(`✅ 溯源连接线移除成功: ${connectionId}`);
          } catch (error) {
            console.error(`❌ 移除溯源连接线失败: ${connectionId}`, error);
            this.connections.delete(connectionId);
          }
        }
      }
    } catch (error) {
      console.error(`❌ 移除溯源连接线失败:`, error);
    }
  }
}
```

#### 6.2 便签溯源按钮实现

```tsx
// src/components/notes/StickyNote.tsx (溯源按钮部分)
// 处理溯源按钮点击
const handleSourceButtonClick = useCallback(
  async (e: React.MouseEvent) => {
    if (isStreaming) return;

    e.stopPropagation();
    e.preventDefault();

    // 检查是否有溯源数据
    const hasSourceNoteIds =
      note.sourceNoteIds && note.sourceNoteIds.length > 0;
    const hasSourceNotesContent =
      note.sourceNotesContent && note.sourceNotesContent.length > 0;

    if (!hasSourceNoteIds && !hasSourceNotesContent) {
      return;
    }

    // 根据便签生成模式决定行为
    if (note.generationMode === "replace" && hasSourceNotesContent) {
      // 替换模式：打开源便签查看弹窗
      setSourceNotesModalVisible(true);
      return;
    }

    // 汇总模式或没有生成模式标识：显示/隐藏连接线
    if (!hasSourceNoteIds) {
      return;
    }

    // 获取当前所有便签，验证源便签是否存在
    const validSourceNoteIds = note.sourceNoteIds!.filter((sourceId) =>
      allNotes.some((n) => n.id === sourceId)
    );

    if (validSourceNoteIds.length === 0) {
      console.warn("没有找到有效的源便签");
      return;
    }

    if (sourceConnectionsVisible) {
      // 隐藏溯源连接线
      connectionLineManager.removeAllSourceConnectionsToNote(note.id);
      setSourceConnectionsVisible(false);

      // 通知所有源便签更新其连接状态
      for (const sourceNoteId of validSourceNoteIds) {
        const event = new CustomEvent("sourceConnectionChanged", {
          detail: { noteId: sourceNoteId },
        });
        window.dispatchEvent(event);
      }
    } else {
      // 显示溯源连接线 - 只尝试创建有效源便签的连接
      let successCount = 0;
      for (const sourceNoteId of validSourceNoteIds) {
        const success = await connectionLineManager.createSourceConnection(
          sourceNoteId,
          note.id
        );
        if (success) {
          successCount++;
        }
      }

      if (successCount > 0) {
        setSourceConnectionsVisible(true);

        // 通知所有源便签更新其连接状态
        for (const sourceNoteId of validSourceNoteIds) {
          const event = new CustomEvent("sourceConnectionChanged", {
            detail: { noteId: sourceNoteId },
          });
          window.dispatchEvent(event);
        }
      } else {
        console.warn("没有成功创建任何溯源连接线");
      }
    }
  },
  [
    note.id,
    note.sourceNoteIds,
    isStreaming,
    sourceConnectionsVisible,
    allNotes,
    onUpdate,
  ]
);
```

### 第七步：数据类型定义

#### 7.1 核心类型定义

```typescript
// src/components/types.ts
import type { JSONContent } from "@tiptap/react";

// 便签基础接口
export interface StickyNote {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  content: JSONContent;
  title?: string;
  color: "yellow" | "blue" | "green" | "pink" | "purple";
  isNew?: boolean;
  zIndex: number;
  isEditing?: boolean;
  isTitleEditing?: boolean;
  createdAt: Date;
  updatedAt: Date;

  // 连接相关属性
  isConnected?: boolean;
  connectionIndex?: number;

  // 溯源相关属性
  sourceNoteIds?: string[]; // 汇总模式：源便签ID列表
  sourceNotesContent?: SourceNoteContent[]; // 替换模式：完整源便签内容
  generationMode?: "summary" | "replace"; // 生成模式

  // AI相关属性
  thinkingChain?: ThinkingChain; // 思维链数据
  hasThinking?: boolean; // 是否有思维链
}

// 源便签内容接口（用于替换模式）
export interface SourceNoteContent {
  id: string;
  title?: string;
  content: JSONContent;
  color: string;
  createdAt: Date;
  deletedAt: Date; // 记录删除时间
}

// 思维链接口
export interface ThinkingChain {
  steps: ThinkingStep[];
  totalSteps: number;
  summary: string;
}

// 思维步骤接口
export interface ThinkingStep {
  id: string;
  content: string;
  stepType: "analysis" | "reasoning" | "conclusion" | "question" | "idea";
  timestamp: Date;
  order: number;
}
```

### 第八步：集成到主画布

#### 8.1 主画布组件集成

```tsx
// src/components/canvas/InfiniteCanvasNew.tsx (主要集成部分)
import React, { useCallback, useRef, useEffect } from "react";
import { useConnectionStore } from "../../stores/connectionStore";
import StickyNoteSlots from "./StickyNoteSlots";
import { connectionLineManager } from "../../utils/connectionLineManager";

const InfiniteCanvasNew: React.FC = () => {
  const canvasRef = useRef<HTMLDivElement>(null);

  // 连接状态
  const {
    connectedNotes,
    connectionMode,
    isVisible: slotsVisible,
    addConnection,
    removeConnection,
    clearAllConnections,
    setConnectionMode,
    updateConnectionLines,
  } = useConnectionStore();

  // 处理便签连接
  const handleNoteConnect = useCallback(
    (note: StickyNote) => {
      const success = addConnection(note);
      if (success) {
        console.log(`便签 ${note.id} 已连接到插槽`);
      } else {
        console.warn(`便签 ${note.id} 连接失败`);
      }
    },
    [addConnection]
  );

  // 监听画布变化，更新连接线位置
  useEffect(() => {
    const handleCanvasChange = () => {
      updateConnectionLines();
    };

    // 监听画布缩放和移动事件
    const canvas = canvasRef.current;
    if (canvas) {
      canvas.addEventListener("wheel", handleCanvasChange);
      canvas.addEventListener("mousemove", handleCanvasChange);
    }

    return () => {
      if (canvas) {
        canvas.removeEventListener("wheel", handleCanvasChange);
        canvas.removeEventListener("mousemove", handleCanvasChange);
      }
    };
  }, [updateConnectionLines]);

  return (
    <div className="infinite-canvas-container" ref={canvasRef}>
      {/* 画布内容 */}
      <div className="canvas-content">
        {/* 便签渲染 */}
        {notes.map((note) => (
          <StickyNote
            key={note.id}
            note={note}
            onConnect={handleNoteConnect}
            // ... 其他属性
          />
        ))}
      </div>

      {/* 便签插槽容器 */}
      <StickyNoteSlots
        connectedNotes={connectedNotes}
        connectionMode={connectionMode}
        onModeChange={setConnectionMode}
        onRemoveConnection={removeConnection}
        onClearAllConnections={clearAllConnections}
        visible={slotsVisible}
      />

      {/* AI生成控制台等其他组件 */}
    </div>
  );
};

export default InfiniteCanvasNew;
```

## 复刻要点总结

### 关键技术要点

1. **Leader Line 库**：用于绘制连接线，需要在 public 目录放置 leader-line.min.js 文件
2. **Zustand 状态管理**：管理连接状态，支持多组件间状态同步
3. **DOM 操作优化**：使用 requestAnimationFrame 确保 DOM 更新后再创建连接线
4. **事件系统**：使用 CustomEvent 进行组件间通信
5. **TypeScript 类型安全**：完整的类型定义确保代码质量

### 样式设计要点

1. **响应式设计**：支持移动端和桌面端
2. **动画效果**：连接状态的脉冲动画和悬停效果
3. **视觉层次**：使用 z-index 和透明度管理显示层次
4. **用户体验**：清晰的视觉反馈和操作提示

### 功能特性

1. **双模式支持**：汇总模式保留原便签，替换模式删除原便签
2. **溯源追踪**：完整记录便签生成来源
3. **思维链显示**：支持 AI 思考过程的可视化
4. **实时连接线**：动态更新连接线位置

### 部署注意事项

1. 确保 Leader Line 库正确加载
2. 配置 AI 服务接口
3. 设置 IndexedDB 存储
4. 优化性能和内存使用

通过以上步骤，您可以完整复刻便签链接插槽汇总功能，实现一个功能完整、用户体验良好的便签连接系统。
