# 无限画布软件对比分析

## 🎨 主流无限画布软件的实现方式

### 1. **Miro（在线白板）**

#### 坐标系统

- **初始位置：** 画布中心（0, 0）
- **坐标原点：** 屏幕中心对齐画布中心
- **坐标范围：** 理论上无限，但实际有性能限制

#### 特点

```
初始状态：
┌────────────────────┐
│                    │
│    ┌──────┐        │
│    │(0,0) │ ← 中心 │
│    └──────┘        │
│                    │
└────────────────────┘
```

**设计理念：**

- ✅ 用户可以向四面八方自由扩展
- ✅ 新内容从中心开始，更符合直觉
- ✅ 协作时，所有人看到相同的"起点"

**技术实现：**

```typescript
初始视口：
{
  offset: { x: screenWidth/2, y: screenHeight/2 },
  scale: 1
}
```

---

### 2. **Figma（设计工具）**

#### 坐标系统

- **初始位置：** 画布中心附近，但不完全是（0, 0）
- **坐标原点：** 左上角为（0, 0）
- **设计面板：** 每个 Frame 有独立坐标系

#### 特点

```
Figma 的混合方式：
┌────────────────────────────┐
│  (-x, -y)    |    (+x, -y)  │
│              |              │
│──────────────┼──────────────│ ← Y轴
│              |              │
│  (-x, +y)    |    (+x, +y)  │
└────────────────────────────┘
         X轴
```

**设计理念：**

- ✅ 支持负坐标，便于对称布局
- ✅ Frame 作为容器，有独立的坐标系
- ✅ 可以无限向任意方向扩展

**特殊设计：**

- 有 "重置缩放" 功能（Cmd+0）回到当前选中对象
- 有 "缩放到适配" 功能（Cmd+1）显示所有对象

---

### 3. **Notion Canvas（概念画布）**

#### 坐标系统

- **初始位置：** 画布中心
- **坐标原点：** 中心点为（0, 0）
- **块布局：** 使用相对定位

#### 特点

```
Notion 的简洁方式：
       负坐标区
          ↓
    ┌─────────────┐
    │      ↑      │
    │   负坐标    │
←───┼─────●─────┼───→
    │   (0,0)    │
    │      ↓      │
    │   正坐标    │
    └─────────────┘
          ↓
       正坐标区
```

**设计理念：**

- ✅ 极简主义，中心起点
- ✅ 每个块都是绝对定位
- ✅ 无限扩展但有"建议区域"

---

### 4. **Excalidraw（手绘白板）**

#### 坐标系统

- **初始位置：** 画布中心
- **坐标原点：** 中心为（0, 0）
- **无限画布：** 真正的无限（无边界）

#### 特点

```javascript
// Excalidraw 的实现方式
const DEFAULT_STATE = {
  scrollX: 0, // 画布偏移
  scrollY: 0,
  zoom: { value: 1 },
};

// 屏幕中心 = 画布 (0, 0)
```

**设计理念：**

- ✅ 完全无限，无边界感知
- ✅ 性能优化：只渲染可见元素
- ✅ 元素坐标支持正负值

**技术实现：**

- Canvas API 动态绘制
- 视口裁剪（viewport culling）
- 四叉树空间索引

---

### 5. **Obsidian Canvas（笔记画布）**

#### 坐标系统

- **初始位置：** 画布中心偏左上
- **坐标原点：** 第一个节点位置
- **动态中心：** 基于内容自动调整

#### 特点

```
Obsidian 的动态方式：
初始：        添加节点后：
  ┌───┐         ┌─────────┐
  │ ● │         │  ●   ●  │
  └───┘         │  ● ● ●  │
                └─────────┘
                自动居中
```

**设计理念：**

- ✅ 内容驱动的视口
- ✅ 自动缩放到适配内容
- ✅ 支持负坐标但不强调

---

### 6. **Infinite Canvas（开源库）**

#### 坐标系统

- **标准实现：** 中心为原点
- **参考坐标系：** 数学坐标系（中心为 0,0）

```javascript
// 典型的无限画布库实现
class InfiniteCanvas {
  constructor() {
    this.camera = {
      x: 0, // 相机位置（画布中心）
      y: 0,
      zoom: 1,
    };
  }

  // 屏幕坐标转画布坐标
  screenToWorld(screenX, screenY) {
    return {
      x: (screenX - canvas.width / 2) / zoom + camera.x,
      y: (screenY - canvas.height / 2) / zoom + camera.y,
    };
  }
}
```

---

## 📊 对比总结

| 软件                 | 初始位置 | 坐标原点  | 支持负坐标 | 边界处理        |
| -------------------- | -------- | --------- | ---------- | --------------- |
| **Miro**             | 中心     | 中心(0,0) | ✅         | 无限            |
| **Figma**            | 中心     | 左上(0,0) | ✅         | 无限            |
| **Notion Canvas**    | 中心     | 中心(0,0) | ✅         | 无限            |
| **Excalidraw**       | 中心     | 中心(0,0) | ✅         | 无限            |
| **Obsidian Canvas**  | 内容中心 | 动态      | ✅         | 无限            |
| **你的项目（当前）** | 左上角   | 左上(0,0) | ⚠️         | 有限(100k×100k) |

---

## 🎯 行业标准做法

### ✅ 最佳实践（95%的无限画布软件都这样做）

```typescript
// 标准的无限画布初始化
const INITIAL_VIEWPORT = {
  scale: 1,
  offset: {
    x: window.innerWidth / 2, // 屏幕中心
    y: window.innerHeight / 2, // 屏幕中心
  },
};

// 这样设置后：
// - 屏幕中心对齐画布坐标 (0, 0)
// - 可以向任意方向自由扩展
// - 用户体验更"无限"
```

### 🎨 视觉效果对比

**左上角起点（当前方案）：**

```
✗ 感觉受限制            ✗ 向左上拖动空间小
    ┌──────────           ┌──────────
    │ 👁️                  │
    │  ← 视口              │ 大部分空间
    │                     │ 在右下方
    │                     │

    用户感觉被"困在"左上角
```

**中心起点（标准方案）：**

```
✓ 感觉自由              ✓ 四个方向均衡
         │                    │
    ─────┼─────           ─────┼─────
         │ 👁️                 │
         │ ← 视口              │
         │                    │

    用户感觉站在"世界中心"
```

---

## 🔧 技术实现对比

### 方案 A：左上角起点（你的当前方案）

**优点：**

- ✅ Web 开发传统习惯
- ✅ 实现简单，坐标直观
- ✅ 不需要处理负坐标

**缺点：**

- ❌ 不符合"无限画布"的用户心智模型
- ❌ 向左上扩展空间有限
- ❌ 与主流软件体验不一致

**适用场景：**

- 文档型应用（从左上往右下排列）
- 传统网页布局
- 内容有明确起点的应用

---

### 方案 B：中心起点（推荐）

**优点：**

- ✅ 符合用户对"无限"的预期
- ✅ 向四面八方均衡扩展
- ✅ 与主流软件一致的体验
- ✅ 更适合协作场景

**缺点：**

- ⚠️ 需要处理负坐标
- ⚠️ 坐标计算稍复杂

**适用场景：**

- 白板类应用 ✅
- 思维导图 ✅
- 可视化图表 ✅
- 创意工作空间 ✅

**实现代码：**

```typescript
// 修改 DEFAULT_VIEWPORT
const DEFAULT_VIEWPORT: CanvasViewport = {
  scale: 1,
  offset: {
    x: typeof window !== "undefined" ? window.innerWidth / 2 : 960,
    y: typeof window !== "undefined" ? window.innerHeight / 2 : 540,
  },
  minScale: 0.25,
  maxScale: 2,
};
```

---

### 方案 C：混合方案（Figma 风格）

**特点：**

- 原点在左上角（0,0）
- 但初始视口居中
- 支持负坐标

**实现：**

```typescript
// 左上角是 (0, 0)
// 但视口初始看向中心区域
const DEFAULT_VIEWPORT = {
  scale: 1,
  offset: {
    // 假设我们定义画布中心为 (0, 0)
    // 网格从 (-50000, -50000) 到 (50000, 50000)
    x: window.innerWidth / 2,
    y: window.innerHeight / 2,
  },
};
```

---

## 📐 真正的"无限"画布实现

### 技术方案对比

#### 1. **固定大尺寸方案（你的当前方案）**

```typescript
网格尺寸: 100000 × 100000 px
优点: 实现简单
缺点: 仍有边界
适用: 中小型项目
```

#### 2. **动态网格重定位（推荐）**

```typescript
// 监听画布偏移，接近边界时调整网格
useEffect(() => {
  const gridWidth = 100000;
  const halfGrid = 50000;

  // 当接近边界时，调整网格位置
  if (Math.abs(offset.x) > halfGrid * 0.8) {
    // 重新定位网格，保持连续性
    const newGridOffsetX = Math.floor(offset.x / gridWidth) * gridWidth;
    setGridOffset({ x: newGridOffsetX, y: gridOffset.y });
  }
}, [offset]);
```

**优点：**

- ✅ 真正的无限感觉
- ✅ 性能可控
- ✅ 无边界感知

#### 3. **Canvas API 动态绘制（Excalidraw 方案）**

```typescript
function drawGrid(ctx, viewport) {
  const gridSize = 20 * viewport.scale;

  // 只绘制可见区域
  const startX = Math.floor(-viewport.offset.x / gridSize) * gridSize;
  const startY = Math.floor(-viewport.offset.y / gridSize) * gridSize;
  const endX = startX + canvas.width;
  const endY = startY + canvas.height;

  for (let x = startX; x <= endX; x += gridSize) {
    for (let y = startY; y <= endY; y += gridSize) {
      ctx.fillRect(x, y, 1, 1);
    }
  }
}
```

**优点：**

- ✅ 完全无限
- ✅ 性能最优
- ✅ 灵活控制

**缺点：**

- ❌ 实现复杂
- ❌ 需要处理 Canvas 渲染

#### 4. **SVG Pattern 方案（推荐用于网格）**

```html
<svg width="0" height="0">
  <defs>
    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
      <circle cx="1" cy="1" r="1" fill="rgba(0,0,0,0.1)" />
    </pattern>
  </defs>
</svg>

<div
  style="
  background: url(#grid);
  width: 100vw;
  height: 100vh;
  background-position: {offset.x}px {offset.y}px;
  background-size: {20 * scale}px {20 * scale}px;
"
/>
```

**优点：**

- ✅ 浏览器原生支持无限重复
- ✅ 性能好
- ✅ 代码简洁

---

## 🎯 建议方案

### 对于你的项目，我建议：

### ✨ 短期改进（立即可做）

**1. 修改初始位置到中心**

```typescript
// src/store/canvasStore.ts
const DEFAULT_VIEWPORT: CanvasViewport = {
  scale: 1,
  offset: {
    x: typeof window !== "undefined" ? window.innerWidth / 2 : 960,
    y: typeof window !== "undefined" ? window.innerHeight / 2 : 540,
  },
  minScale: 0.25,
  maxScale: 2,
};
```

**影响：**

- ✅ 立即让用户体验更"无限"
- ✅ 与主流软件体验一致
- ✅ 改动最小，风险低

---

### 🚀 长期优化（逐步实现）

**2. 使用 SVG Pattern 实现真无限网格**

```typescript
// 替换当前的 CSS 背景方案
// 用 SVG pattern 实现完全无限的网格
```

**3. 添加动态网格重定位**

```typescript
// 当接近边界时自动调整，实现真正无限
```

**4. 性能优化**

```typescript
// 使用四叉树管理便签
// 实现更高效的视口裁剪
```

---

## 📚 参考资源

### 开源项目参考

1. **Excalidraw**

   - GitHub: https://github.com/excalidraw/excalidraw
   - 最佳的无限画布实现参考

2. **tldraw**

   - GitHub: https://github.com/tldraw/tldraw
   - 现代化的无限画布库

3. **perfect-freehand**
   - GitHub: https://github.com/steveruizok/perfect-freehand
   - 手绘效果实现

### 技术文章

- "Building an Infinite Canvas" by Steve Ruiz
- "How Figma's Multiplayer Technology Works"
- "Spatial Indexing with Quadtrees"

---

## 🎨 总结

**主流无限画布软件的共识：**

1. ✅ **初始位置在画布中心**（95%的软件）
2. ✅ **支持四向均衡扩展**（无方向限制）
3. ✅ **支持负坐标**（完整的坐标系）
4. ✅ **真正的无限感觉**（无边界感知）
5. ✅ **性能优化**（只渲染可见内容）

**你的项目目前的差距：**

- ❌ 初始位置在左上角（不符合直觉）
- ⚠️ 网格有固定边界（100k×100k）
- ⚠️ 向左上扩展受限

**推荐优先改进：**

1. 🎯 **立即：** 修改初始位置到中心
2. 🎯 **短期：** 扩大网格或使用 SVG pattern
3. 🎯 **长期：** 实现真正的无限画布（动态网格）

需要我帮你实现这些改进吗？我可以从修改初始位置开始！
