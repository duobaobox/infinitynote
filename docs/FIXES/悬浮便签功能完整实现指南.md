# 悬浮便签功能完整实现指南

## 📋 目录
- [功能概述](#功能概述)
- [技术架构](#技术架构)
- [核心实现](#核心实现)
- [关键技术点](#关键技术点)
- [数据流设计](#数据流设计)
- [完整代码实现](#完整代码实现)
- [常见问题与解决方案](#常见问题与解决方案)

---

## 功能概述

### 什么是悬浮便签？
悬浮便签是一个独立的、始终置顶的桌面窗口，用户可以将画布中的任意便签"提取"出来，以悬浮窗的形式固定在桌面上，方便随时查看和编辑。

### 核心特性
1. **独立窗口**：每个悬浮便签都是一个独立的 Electron BrowserWindow
2. **始终置顶**：悬浮窗口永远显示在其他窗口之上
3. **无边框设计**：透明背景 + 无边框，提供现代化的视觉体验
4. **可拖拽移动**：通过标题栏拖拽移动窗口位置
5. **可调整大小**：支持窗口大小调整
6. **双向同步**：悬浮便签与原始便签数据实时同步
7. **独立编辑**：在悬浮窗中可以独立编辑标题和内容
8. **跨平台**：支持 Windows、macOS、Linux

---

## 技术架构

### 整体架构图
```
┌─────────────────────────────────────────────────────────────┐
│                      主窗口 (Main Window)                    │
│  ┌────────────────────────────────────────────────────────┐ │
│  │             无限画布 (Infinite Canvas)                  │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐             │ │
│  │  │ 便签 1    │  │ 便签 2    │  │ 便签 3    │             │ │
│  │  │          │  │          │  │  [浮窗]   │             │ │
│  │  └──────────┘  └──────────┘  └──────────┘             │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                          ↓ 点击"悬浮"按钮
                          ↓ IPC 通信
┌─────────────────────────────────────────────────────────────┐
│                    Electron Main Process                     │
│          createFloatingNoteWindow(noteData)                  │
└─────────────────────────────────────────────────────────────┘
                          ↓ 创建新窗口
┌─────────────────────────────────────────────────────────────┐
│              悬浮窗口 (Floating Window)                       │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  [拖拽区域 - 可移动窗口]                    [×关闭]    │ │
│  │  ═══════════════════════════════════════════════════  │ │
│  │  标题：便签标题                                        │ │
│  │  ───────────────────────────────────────────────────  │ │
│  │  内容区域                                              │ │
│  │  - 支持富文本编辑                                      │ │
│  │  - 实时同步到主窗口                                    │ │
│  │                                                        │ │
│  └────────────────────────────────────────────────────────┘ │
│          ↕ 双向数据同步 (IPC 通信)                          │
└─────────────────────────────────────────────────────────────┘
```

### 技术栈
- **Electron**: 跨平台桌面应用框架
- **React**: 前端 UI 框架
- **TypeScript**: 类型安全
- **IPC (进程间通信)**: 主进程与渲染进程通信
- **Context Bridge**: 安全的 API 暴露

---

## 核心实现

### 1. Electron 主进程配置 (main.cjs)

#### 1.1 全局变量管理
```javascript
// 悬浮窗口管理 - 使用 Map 管理多个悬浮窗口
let floatingWindows = new Map(); // key: noteId, value: BrowserWindow

// 主窗口引用
let mainWindow;
```

#### 1.2 创建悬浮窗口函数
```javascript
function createFloatingNoteWindow(noteData) {
  const { noteId, title, content, color, width, height } = noteData;

  // 1️⃣ 检查窗口是否已存在
  if (floatingWindows.has(noteId)) {
    const existingWindow = floatingWindows.get(noteId);
    if (!existingWindow.isDestroyed()) {
      existingWindow.focus();
      existingWindow.show();
      return existingWindow;
    } else {
      floatingWindows.delete(noteId);
    }
  }

  // 2️⃣ 创建新的悬浮窗口
  const floatingWindow = new BrowserWindow({
    width: Math.max(width, 300),        // 最小宽度 300px
    height: Math.max(height, 200),      // 最小高度 200px
    minWidth: 250,
    minHeight: 150,
    frame: false,                       // ⭐ 无边框窗口
    transparent: true,                  // ⭐ 透明背景
    alwaysOnTop: true,                  // ⭐ 始终在顶部
    resizable: true,                    // 可调整大小
    movable: true,                      // 可移动
    skipTaskbar: false,                 // 在任务栏中显示
    title: `悬浮便签 - ${title || "无标题"}`,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      enableRemoteModule: false,
      preload: path.join(__dirname, "preload.cjs"),
      webSecurity: !isDev,
    },
    show: false,                        // 延迟显示
  });

  // 3️⃣ 加载悬浮页面
  const floatingUrl = isDev
    ? `http://localhost:5173/floating.html?noteId=${encodeURIComponent(noteId)}`
    : `file://${path.join(__dirname, "../dist/floating.html")}?noteId=${encodeURIComponent(noteId)}`;

  floatingWindow.loadURL(floatingUrl);

  // 4️⃣ 窗口准备显示时的回调
  floatingWindow.once("ready-to-show", () => {
    floatingWindow.show();
    floatingWindow.focus();

    // 发送便签数据到渲染进程
    setTimeout(() => {
      if (!floatingWindow.isDestroyed()) {
        floatingWindow.webContents.send("note-data", noteData);
      }
    }, 500); // 延迟确保页面完全加载
  });

  // 5️⃣ 窗口关闭时清理
  floatingWindow.on("closed", () => {
    floatingWindows.delete(noteId);
  });

  // 6️⃣ 监听窗口大小变化，同步到主窗口
  floatingWindow.on("resize", () => {
    if (!floatingWindow.isDestroyed()) {
      const bounds = floatingWindow.getBounds();
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send("floating-note-resized", {
          noteId,
          width: bounds.width,
          height: bounds.height,
        });
      }
    }
  });

  // 7️⃣ 存储窗口引用
  floatingWindows.set(noteId, floatingWindow);

  return floatingWindow;
}
```

#### 1.3 IPC 处理程序
```javascript
// 创建悬浮便签
ipcMain.handle("create-floating-note", (event, noteData) => {
  try {
    createFloatingNoteWindow(noteData);
    return { success: true };
  } catch (error) {
    console.error("创建悬浮便签失败:", error);
    return { success: false, error: error.message };
  }
});

// 关闭悬浮便签
ipcMain.handle("close-floating-note", (event, noteId) => {
  try {
    const window = floatingWindows.get(noteId);
    if (window && !window.isDestroyed()) {
      window.close();
    }
    floatingWindows.delete(noteId);
    return { success: true };
  } catch (error) {
    console.error("关闭悬浮便签失败:", error);
    return { success: false, error: error.message };
  }
});

// 更新悬浮便签 - 双向同步的核心
ipcMain.handle("update-floating-note", (event, noteId, updates) => {
  try {
    const window = floatingWindows.get(noteId);
    
    // 更新悬浮窗口
    if (window && !window.isDestroyed()) {
      window.webContents.send("note-data-updated", { noteId, ...updates });
    }

    // 同时通知主窗口更新
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send("floating-note-updated", {
        noteId,
        updates,
      });
    }

    return { success: true };
  } catch (error) {
    console.error("更新悬浮便签失败:", error);
    return { success: false, error: error.message };
  }
});

// 获取悬浮便签数据
ipcMain.handle("get-floating-note-data", (event, noteId) => {
  try {
    return { success: true };
  } catch (error) {
    console.error("获取悬浮便签数据失败:", error);
    return { success: false, error: error.message };
  }
});
```

---

### 2. Preload 脚本 (preload.cjs)

```javascript
const { contextBridge, ipcRenderer } = require("electron");

contextBridge.exposeInMainWorld("electronAPI", {
  // 悬浮便签功能 - 暴露给渲染进程的 API
  createFloatingNote: (noteData) =>
    ipcRenderer.invoke("create-floating-note", noteData),
  
  closeFloatingNote: (noteId) =>
    ipcRenderer.invoke("close-floating-note", noteId),
  
  updateFloatingNote: (noteId, updates) =>
    ipcRenderer.invoke("update-floating-note", noteId, updates),
  
  getFloatingNoteData: (noteId) =>
    ipcRenderer.invoke("get-floating-note-data", noteId),

  // 菜单事件监听
  onMenuAction: (callback) => {
    const menuEvents = [
      "note-data",              // 悬浮便签数据
      "note-data-updated",      // 便签数据更新
      "floating-note-updated",  // 悬浮便签更新通知主窗口
      // ... 其他事件
    ];

    const handlers = {};

    menuEvents.forEach((event) => {
      const handler = (electronEvent, data) => {
        callback(event, data);
      };
      handlers[event] = handler;
      ipcRenderer.on(event, handler);
    });

    // 返回清理函数
    return () => {
      menuEvents.forEach((event) => {
        if (handlers[event]) {
          ipcRenderer.removeListener(event, handlers[event]);
        }
      });
    };
  },

  // 平台信息
  platform: process.platform,
  isDev: process.env.NODE_ENV === "development",
  isElectron: true,
});
```

---

### 3. 悬浮窗口 HTML (floating.html)

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/icon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>悬浮便签 - Infinity Notes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 
                         'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            -webkit-font-smoothing: antialiased;
            overflow: hidden;
        }

        #root {
            height: 100%;
            width: 100%;
        }

        /* 悬浮窗口专用样式 */
        .floating-window {
            height: 100vh;
            width: 100vw;
            background: transparent;
            position: relative;
        }

        /* ⭐ 关键：启用拖拽功能 */
        .floating-drag-area {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 32px;
            -webkit-app-region: drag;  /* 启用拖拽 */
            background: rgba(0, 0, 0, 0.02);
            z-index: 1000;
        }

        /* 悬浮窗口关闭按钮 */
        .floating-close-button {
            position: absolute;
            top: 6px;
            right: 8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 95, 87, 0.8);
            border: none;
            cursor: pointer;
            color: white;
            font-size: 12px;
            z-index: 1001;
            -webkit-app-region: no-drag;  /* 按钮区域禁用拖拽 */
        }

        /* 隐藏原始便签的某些元素 */
        .floating-note-wrapper .settings-toolbar {
            display: none !important;  /* 隐藏设置工具栏 */
        }

        .floating-note-wrapper .connection-point {
            display: none !important;  /* 隐藏连接点 */
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="module" src="/src/pages/FloatingNote.tsx"></script>
</body>
</html>
```

---

### 4. 悬浮窗口 React 组件 (FloatingNote.tsx)

```typescript
import React, { useEffect, useState, useCallback, useRef } from "react";
import ReactDOM from "react-dom/client";
import { ConfigProvider, Button } from "antd";
import { CloseOutlined } from "@ant-design/icons";
import zhCN from "antd/locale/zh_CN";
import TitleEditor from "../components/notes/TitleEditor";
import BasicEditor from "../components/notes/BasicEditor";
import BasicToolbar from "../components/notes/BasicToolbar";
import { useDebounce } from "../hooks";
import type { StickyNote as StickyNoteType } from "../components/types";

interface FloatingNoteData {
  noteId: string;
  title: string;
  content: string;
  color: string;
  width: number;
  height: number;
  isEditing?: boolean;
  isTitleEditing?: boolean;
}

const FloatingNote: React.FC = () => {
  // ===== 状态管理 =====
  const [noteData, setNoteData] = useState<StickyNoteType | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [isTitleEditing, setIsTitleEditing] = useState(false);
  const [localTitle, setLocalTitle] = useState("");
  const [localContent, setLocalContent] = useState("");
  const [editorInstance, setEditorInstance] = useState<any>(null);
  const [windowWidth, setWindowWidth] = useState(window.innerWidth || 300);

  // ===== 定时器管理 =====
  const timersRef = useRef<Set<NodeJS.Timeout>>(new Set());

  const safeSetTimeout = useCallback((callback: () => void, delay: number) => {
    const timer = setTimeout(() => {
      timersRef.current.delete(timer);
      callback();
    }, delay);
    timersRef.current.add(timer);
    return timer;
  }, []);

  useEffect(() => {
    return () => {
      timersRef.current.forEach((timer) => clearTimeout(timer));
      timersRef.current.clear();
    };
  }, []);

  // ===== URL 参数解析 =====
  const urlParams = new URLSearchParams(window.location.search);
  const noteId = urlParams.get("noteId");

  // ===== 监听窗口大小变化 =====
  useEffect(() => {
    const handleResize = () => {
      setWindowWidth(window.innerWidth);
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  // ===== 防抖保存内容 =====
  const [debouncedSaveContent] = useDebounce((content: string) => {
    if (noteData && content !== noteData.content && 
        window.electronAPI?.updateFloatingNote) {
      setNoteData((prev) => (prev ? { ...prev, content } : null));
      window.electronAPI.updateFloatingNote(noteData.id, { content });
    }
  }, 300);

  // ===== 防抖保存标题 =====
  const [debouncedSaveTitle] = useDebounce((title: string) => {
    if (noteData && title !== noteData.title && 
        window.electronAPI?.updateFloatingNote) {
      setNoteData((prev) => (prev ? { ...prev, title } : null));
      window.electronAPI.updateFloatingNote(noteData.id, { title });
    }
  }, 300);

  // ===== 标题变化处理 =====
  const handleTitleChange = useCallback(
    (newTitle: string) => {
      setLocalTitle(newTitle);
      debouncedSaveTitle(newTitle);
    },
    [debouncedSaveTitle]
  );

  // ===== 内容变化处理 =====
  const handleContentChange = useCallback(
    (newContent: string) => {
      setLocalContent(newContent);
      debouncedSaveContent(newContent);
    },
    [debouncedSaveContent]
  );

  // ===== 编辑状态管理 =====
  const startTitleEditing = useCallback(() => {
    if (isEditing) return;
    if (window.electronAPI?.updateFloatingNote && noteData) {
      window.electronAPI.updateFloatingNote(noteData.id, {
        isTitleEditing: true,
      });
    }
    setIsTitleEditing(true);
    setLocalTitle(noteData?.title || "");
  }, [isEditing, noteData]);

  const stopTitleEditing = useCallback(() => {
    if (window.electronAPI?.updateFloatingNote && noteData) {
      window.electronAPI.updateFloatingNote(noteData.id, {
        title: localTitle,
        isTitleEditing: false,
      });
    }
    setIsTitleEditing(false);
  }, [noteData, localTitle]);

  const startEditing = useCallback(() => {
    if (isTitleEditing) return;
    if (window.electronAPI?.updateFloatingNote && noteData) {
      window.electronAPI.updateFloatingNote(noteData.id, {
        isEditing: true,
      });
    }
    setLocalContent(noteData?.content || "");
    setIsEditing(true);
  }, [isTitleEditing, noteData]);

  const stopEditing = useCallback(() => {
    if (window.electronAPI?.updateFloatingNote && noteData) {
      window.electronAPI.updateFloatingNote(noteData.id, {
        content: localContent,
        isEditing: false,
        updatedAt: new Date(),
      });
    }
    setIsEditing(false);
    if (isTitleEditing) {
      stopTitleEditing();
    }
  }, [noteData, localContent, isTitleEditing, stopTitleEditing]);

  // ===== 接收便签数据和更新 =====
  useEffect(() => {
    const handleNoteData = (_event: any, data: FloatingNoteData) => {
      console.log("接收到便签数据:", data);
      const note: StickyNoteType = {
        id: data.noteId,
        title: data.title,
        content: data.content,
        color: data.color as any,
        width: data.width,
        height: data.height,
        x: 0,
        y: 0,
        zIndex: 1,
        isEditing: data.isEditing || false,
        isTitleEditing: data.isTitleEditing || false,
        isNew: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      setNoteData(note);
      setLocalTitle(note.title);
      setLocalContent(note.content);
      setIsEditing(data.isEditing || false);
      setIsTitleEditing(data.isTitleEditing || false);
      setIsInitialized(true);
      setIsLoading(false);
    };

    const handleNoteDataUpdated = (_event: any, data: any) => {
      if (data.noteId === noteId) {
        setNoteData((prev: StickyNoteType | null) => {
          if (prev) {
            const updated = { ...prev, ...data };

            if (data.isEditing !== undefined) {
              setIsEditing(data.isEditing);
              if (data.isEditing) {
                setLocalContent(updated.content);
              }
            }

            if (data.isTitleEditing !== undefined) {
              setIsTitleEditing(data.isTitleEditing);
              if (data.isTitleEditing) {
                setLocalTitle(updated.title);
              }
            }

            if (!data.isEditing && !data.isTitleEditing) {
              if (data.title !== undefined) {
                setLocalTitle(updated.title);
              }
              if (data.content !== undefined) {
                setLocalContent(updated.content);
              }
            }

            return updated;
          }
          return null;
        });
      }
    };

    if (window.electronAPI && window.electronAPI.onMenuAction) {
      const removeListener = window.electronAPI.onMenuAction(
        (eventName: string, data: any) => {
          if (eventName === "note-data") {
            handleNoteData(eventName, data);
          } else if (eventName === "note-data-updated") {
            handleNoteDataUpdated(eventName, data);
          }
        }
      );

      // 超时回退：使用模拟数据
      const timeout = setTimeout(() => {
        if (noteId && isLoading) {
          const mockNote: StickyNoteType = {
            id: noteId,
            title: "悬浮便签",
            content: "这是一个悬浮便签的测试内容。",
            color: "yellow",
            width: 400,
            height: 300,
            x: 0,
            y: 0,
            zIndex: 1,
            isEditing: false,
            isTitleEditing: false,
            isNew: false,
            createdAt: new Date(),
            updatedAt: new Date(),
          };
          setNoteData(mockNote);
          setLocalTitle(mockNote.title);
          setLocalContent(mockNote.content);
          setIsInitialized(true);
          setIsLoading(false);
        }
      }, 1000);

      return () => {
        clearTimeout(timeout);
        removeListener?.();
      };
    }
  }, [noteId, isLoading]);

  // ===== 关闭悬浮便签 =====
  const handleClose = useCallback(() => {
    if (noteId && window.electronAPI?.closeFloatingNote) {
      if (noteData && isInitialized) {
        if (localTitle !== noteData.title) {
          window.electronAPI.updateFloatingNote(noteData.id, {
            title: localTitle,
          });
        }
        if (localContent !== noteData.content) {
          window.electronAPI.updateFloatingNote(noteData.id, {
            content: localContent,
          });
        }
        if (isEditing || isTitleEditing) {
          window.electronAPI.updateFloatingNote(noteData.id, {
            isEditing: false,
            isTitleEditing: false,
          });
        }
      }
      window.electronAPI.closeFloatingNote(noteId);
    }
  }, [noteId, noteData, isInitialized, localTitle, localContent, isEditing, isTitleEditing]);

  // ===== 渲染 =====
  if (isLoading || !noteData || !isInitialized) {
    return (
      <div className="floating-window-loading">
        <div className="loading-content">
          {isLoading ? "加载中..." : "便签数据加载失败"}
        </div>
      </div>
    );
  }

  return (
    <ConfigProvider locale={zhCN}>
      <div className="floating-window">
        <div
          className={`sticky-note color-${noteData.color} ${
            isEditing ? "editing" : ""
          } floating-note-instance`}
          style={{
            position: "relative",
            width: "100%",
            height: "100%",
            display: "flex",
            flexDirection: "column",
          }}
        >
          {/* 标题栏 - 可拖拽 */}
          <div className="sticky-note-header">
            <div
              className="drag-handle"
              style={{
                flexGrow: 1,
                display: "flex",
                alignItems: "center",
                minHeight: "20px",
                cursor: "move",
              }}
              title="拖拽移动悬浮便签"
            >
              {/* 标题编辑器 */}
              {isTitleEditing ? (
                <TitleEditor
                  content={localTitle}
                  onChange={handleTitleChange}
                  onEnter={stopTitleEditing}
                  onEscape={stopTitleEditing}
                  placeholder="便签标题..."
                  autoFocus={true}
                  editable={true}
                />
              ) : (
                <h3
                  className="sticky-note-title"
                  onDoubleClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!isEditing && !isTitleEditing) {
                      startTitleEditing();
                    }
                  }}
                >
                  {localTitle || "便签"}
                </h3>
              )}
            </div>

            {/* 关闭按钮 */}
            <div className="sticky-note-controls">
              <Button
                icon={<CloseOutlined />}
                onClick={handleClose}
                title="关闭悬浮便签"
                type="text"
                size="small"
                className="close-button sticky-note-close-button"
              />
            </div>
          </div>

          {/* 内容区域 */}
          <div className="sticky-note-content">
            <BasicEditor
              content={isEditing ? localContent : noteData.content}
              onChange={handleContentChange}
              onEditorReady={(editor) => {
                setEditorInstance(editor);
                if (isEditing && editor && !editor.isDestroyed) {
                  safeSetTimeout(() => {
                    try {
                      if (editor && !editor.isDestroyed && editor.view) {
                        editor.commands.focus("end");
                      }
                    } catch (error) {
                      console.warn("编辑器聚焦失败:", error);
                    }
                  }, 200);
                }
              }}
              placeholder={isEditing ? "在这里编写便签内容..." : "点击编辑内容..."}
              editable={isEditing}
              autoFocus={false}
              showToolbar={false}
              onClick={(e) => {
                if (!isEditing && !isTitleEditing) {
                  e.preventDefault();
                  e.stopPropagation();
                  startEditing();
                }
              }}
              onBlur={() => {
                if (isEditing) {
                  stopEditing();
                }
              }}
              onKeyDown={(event) => {
                if (event.key === "Escape") {
                  if (isEditing) {
                    stopEditing();
                    return true;
                  }
                }
                return false;
              }}
            />
          </div>

          {/* 编辑工具栏 */}
          {isEditing && editorInstance && (
            <div className="sticky-note-toolbar-container">
              <BasicToolbar editor={editorInstance} className="basic-editor-toolbar compact" />
            </div>
          )}
        </div>
      </div>
    </ConfigProvider>
  );
};

// 挂载 React 应用
const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement
);
root.render(<FloatingNote />);

export default FloatingNote;
```

---

### 5. 悬浮窗口样式 (FloatingNote.css)

```css
/* 悬浮窗口整体样式 */
.floating-window {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  position: relative;
  display: flex;
  flex-direction: column;
  background: #ffffff;
  font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif;
}

/* ⭐ 关键：悬浮窗口拖拽区域 */
.floating-drag-area {
  height: 30px;
  background: rgba(0, 0, 0, 0.03);
  -webkit-app-region: drag;  /* 启用拖拽 */
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding: 0 12px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.06);
  flex-shrink: 0;
  z-index: 10;
  user-select: none;
}

/* 关闭按钮 */
.floating-close-button {
  -webkit-app-region: no-drag;  /* 禁用拖拽 */
  background: #ff5f56;
  border: none;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  color: white;
  font-size: 12px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.floating-close-button:hover {
  background: #ff3b30;
}

/* ⭐ 关键：悬浮便签头部拖拽功能 */
.floating-note-instance .drag-handle {
  -webkit-app-region: drag;  /* 启用拖拽 */
}

/* 标题和控制按钮禁用拖拽 */
.floating-note-instance .sticky-note-title,
.floating-note-instance .sticky-note-title-editor,
.floating-note-instance .sticky-note-controls,
.floating-note-instance .close-button {
  -webkit-app-region: no-drag;  /* 禁用拖拽 */
}

/* 悬浮便签控制按钮始终显示 */
.floating-note-instance .sticky-note-controls {
  opacity: 1 !important;
}

/* 悬浮便签样式调整 */
.sticky-note.floating-note-instance {
  position: static !important;
  left: auto !important;
  top: auto !important;
  width: 100% !important;
  height: 100% !important;
  box-shadow: none !important;
  border: none !important;
  border-radius: 0 !important;
  min-width: unset !important;
  min-height: unset !important;
  max-width: none !important;
  max-height: none !important;
  flex: 1;
}

/* 加载和错误状态 */
.floating-window-loading {
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #ffffff;
}

.loading-content {
  font-size: 14px;
  color: #666;
}

.error-content {
  font-size: 14px;
  color: #f5222d;
}
```

---

### 6. 主窗口便签组件中的触发逻辑 (StickyNote.tsx)

```typescript
// 处理悬浮便签按钮点击
const handleFloatingNote = useCallback(async () => {
  try {
    // 检查是否在 Electron 环境中
    if (window.electronAPI && window.electronAPI.createFloatingNote) {
      // 创建悬浮窗口，传递便签数据及编辑状态
      const result = await window.electronAPI.createFloatingNote({
        noteId: note.id,
        title: note.title,
        content: jsonToText(note.content),  // 将 JSON 转为纯文本
        color: note.color,
        width: note.width,
        height: note.height,
        isEditing: note.isEditing,
        isTitleEditing: note.isTitleEditing,
      });

      if (result.success) {
        message.success("便签已设为悬浮显示");
      } else {
        message.error("创建悬浮便签失败: " + (result.error || "未知错误"));
      }
    } else {
      message.warning("悬浮功能仅在桌面应用中可用");
    }
  } catch (error) {
    console.error("创建悬浮便签失败:", error);
    message.error("创建悬浮便签失败");
  }
}, [note]);

// 在便签工具栏中添加悬浮按钮
<Tooltip title="悬浮显示">
  <Button
    type="text"
    size="small"
    icon={<PushpinOutlined />}
    onClick={(e) => {
      e.stopPropagation();
      handleFloatingNote();
    }}
  />
</Tooltip>
```

---

### 7. 主窗口中的数据同步 (App.tsx)

```typescript
// 监听悬浮便签的更新事件
useEffect(() => {
  if (window.electronAPI?.onMenuAction && appInitialized) {
    console.log("📝 注册悬浮便签状态同步监听器");

    const removeListener = window.electronAPI.onMenuAction(
      (eventName, data) => {
        // 处理悬浮便签向主窗口的更新
        if (eventName === "floating-note-updated" && data?.noteId) {
          console.log("📝 收到悬浮便签更新:", data);

          const { noteId, updates } = data;
          if (noteId && updates) {
            // 更新 Zustand store 中的便签数据
            updateNote(noteId, updates);
          }
        }
      }
    );

    return () => {
      removeListener?.();
    };
  }
}, [appInitialized, updateNote]);
```

---

## 关键技术点

### 1. 无边框窗口实现

**问题**：默认的 Electron 窗口有系统标题栏，不够美观。

**解决方案**：
```javascript
const floatingWindow = new BrowserWindow({
  frame: false,        // 移除边框
  transparent: true,   // 透明背景
  // ...
});
```

**注意事项**：
- 需要自己实现拖拽功能
- 需要自己实现关闭按钮
- macOS 和 Windows 表现可能不同

---

### 2. 窗口拖拽功能

**CSS 实现**：
```css
/* 启用拖拽的区域 */
.drag-handle {
  -webkit-app-region: drag;
}

/* 禁用拖拽的区域（如按钮） */
.close-button {
  -webkit-app-region: no-drag;
}
```

**关键点**：
- `-webkit-app-region: drag` 启用拖拽
- `-webkit-app-region: no-drag` 禁用拖拽
- 需要在无边框窗口中使用
- 按钮等交互元素必须设置为 `no-drag`

---

### 3. 双向数据同步

**同步流程**：

```
悬浮窗口编辑
    ↓
updateFloatingNote(noteId, updates)
    ↓
IPC → 主进程
    ↓
发送到主窗口: floating-note-updated
    ↓
主窗口更新 Zustand Store
    ↓
数据库保存

主窗口编辑
    ↓
updateNote(noteId, updates)
    ↓
数据库保存
    ↓
（可选）通知悬浮窗口刷新
```

**实现代码**：
```javascript
// 主进程
ipcMain.handle("update-floating-note", (event, noteId, updates) => {
  const window = floatingWindows.get(noteId);
  
  // 更新悬浮窗口
  if (window && !window.isDestroyed()) {
    window.webContents.send("note-data-updated", { noteId, ...updates });
  }

  // 通知主窗口
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send("floating-note-updated", {
      noteId,
      updates,
    });
  }
});
```

---

### 4. 窗口生命周期管理

**关键点**：
1. **创建前检查是否已存在**
   ```javascript
   if (floatingWindows.has(noteId)) {
     const existingWindow = floatingWindows.get(noteId);
     if (!existingWindow.isDestroyed()) {
       existingWindow.focus();
       return;
     }
   }
   ```

2. **延迟显示窗口**
   ```javascript
   const floatingWindow = new BrowserWindow({
     show: false,  // 先不显示
     // ...
   });

   floatingWindow.once("ready-to-show", () => {
     floatingWindow.show();
   });
   ```

3. **清理资源**
   ```javascript
   floatingWindow.on("closed", () => {
     floatingWindows.delete(noteId);
   });
   ```

---

### 5. 防止内存泄漏

**定时器清理**：
```typescript
const timersRef = useRef<Set<NodeJS.Timeout>>(new Set());

const safeSetTimeout = useCallback((callback: () => void, delay: number) => {
  const timer = setTimeout(() => {
    timersRef.current.delete(timer);
    callback();
  }, delay);
  timersRef.current.add(timer);
  return timer;
}, []);

useEffect(() => {
  return () => {
    // 组件卸载时清理所有定时器
    timersRef.current.forEach((timer) => clearTimeout(timer));
    timersRef.current.clear();
  };
}, []);
```

**事件监听器清理**：
```typescript
useEffect(() => {
  const removeListener = window.electronAPI.onMenuAction(callback);
  
  return () => {
    removeListener?.();  // 清理监听器
  };
}, []);
```

---

### 6. 跨平台兼容性

**平台检测**：
```javascript
// preload.cjs
contextBridge.exposeInMainWorld("electronAPI", {
  platform: process.platform,  // 'darwin', 'win32', 'linux'
  // ...
});
```

**平台特定样式**：
```css
/* macOS */
.platform-darwin .close-button {
  background: #ff5f56;  /* 红色 */
}

/* Windows */
.platform-win32 .close-button {
  background: #e81123;  /* 微软红 */
}
```

---

## 数据流设计

### 完整数据流图

```
┌─────────────────────────────────────────────────────────────┐
│                  用户操作：点击"悬浮"按钮                      │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│     主窗口 Renderer Process (StickyNote.tsx)                │
│     handleFloatingNote()                                    │
│     → window.electronAPI.createFloatingNote(noteData)       │
└─────────────────────────────────────────────────────────────┘
                          ↓ IPC Invoke
┌─────────────────────────────────────────────────────────────┐
│     Preload Script (preload.cjs)                            │
│     → ipcRenderer.invoke("create-floating-note", noteData)  │
└─────────────────────────────────────────────────────────────┘
                          ↓ IPC
┌─────────────────────────────────────────────────────────────┐
│     Main Process (main.cjs)                                 │
│     ipcMain.handle("create-floating-note")                  │
│     → createFloatingNoteWindow(noteData)                    │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│     创建新的 BrowserWindow                                   │
│     - frame: false                                          │
│     - transparent: true                                     │
│     - alwaysOnTop: true                                     │
│     → loadURL('floating.html?noteId=xxx')                   │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│     Floating Window Renderer Process (FloatingNote.tsx)     │
│     - 解析 URL 参数获取 noteId                               │
│     - 监听 'note-data' 事件                                  │
│     - 接收并显示便签数据                                      │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│     Main Process 发送数据                                    │
│     floatingWindow.webContents.send("note-data", noteData)  │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│     Floating Window 渲染便签                                 │
│     - 显示标题和内容                                          │
│     - 支持编辑                                               │
│     - 监听用户交互                                            │
└─────────────────────────────────────────────────────────────┘
```

### 编辑同步数据流

```
悬浮窗口用户编辑内容
    ↓
handleContentChange(newContent)
    ↓
防抖 300ms
    ↓
window.electronAPI.updateFloatingNote(noteId, { content })
    ↓ IPC
Main Process: ipcMain.handle("update-floating-note")
    ↓
发送到主窗口: mainWindow.webContents.send("floating-note-updated")
    ↓
主窗口: window.electronAPI.onMenuAction("floating-note-updated")
    ↓
updateNote(noteId, updates)  // Zustand Store
    ↓
数据库保存 (IndexedDB)
```

---

## 常见问题与解决方案

### 1. 窗口无法拖拽

**问题**：设置了 `-webkit-app-region: drag` 但窗口无法拖拽。

**原因**：
- 没有设置 `frame: false`
- 拖拽区域被其他元素覆盖
- CSS 优先级问题

**解决方案**：
```css
/* 确保拖拽区域的 z-index 足够高 */
.drag-handle {
  -webkit-app-region: drag;
  z-index: 1000;
  position: relative;
}

/* 确保子元素不阻止拖拽 */
.drag-handle * {
  pointer-events: none;
}

/* 需要交互的元素单独设置 */
.drag-handle .interactive-element {
  pointer-events: auto;
  -webkit-app-region: no-drag;
}
```

---

### 2. 数据不同步

**问题**：悬浮窗口和主窗口的数据不一致。

**原因**：
- IPC 通信失败
- 事件监听器未正确注册
- 状态更新时机问题

**解决方案**：
```typescript
// 1. 确保事件监听器正确注册
useEffect(() => {
  if (!window.electronAPI?.onMenuAction) return;

  const removeListener = window.electronAPI.onMenuAction(
    (eventName, data) => {
      if (eventName === "floating-note-updated") {
        console.log("收到更新:", data);  // 添加日志
        updateNote(data.noteId, data.updates);
      }
    }
  );

  return () => {
    removeListener?.();
  };
}, [updateNote]);

// 2. 主进程确保消息发送
ipcMain.handle("update-floating-note", (event, noteId, updates) => {
  console.log("主进程收到更新请求:", noteId, updates);  // 添加日志
  
  if (mainWindow && !mainWindow.isDestroyed()) {
    console.log("发送更新到主窗口");
    mainWindow.webContents.send("floating-note-updated", {
      noteId,
      updates,
    });
  }
});
```

---

### 3. 窗口透明度问题

**问题**：窗口背景不透明或显示黑色。

**原因**：
- 没有设置 `transparent: true`
- CSS 背景色设置问题
- 平台兼容性问题

**解决方案**：
```javascript
// 1. 确保窗口配置正确
const floatingWindow = new BrowserWindow({
  transparent: true,
  backgroundColor: undefined,  // 不设置背景色
  // ...
});
```

```css
/* 2. CSS 设置透明背景 */
html, body {
  background: transparent;
}

.floating-window {
  background: transparent;
}

.sticky-note {
  background: rgba(255, 255, 255, 0.95);  /* 半透明白色 */
}
```

---

### 4. 内存泄漏

**问题**：长时间运行后内存占用过高。

**原因**：
- 定时器未清理
- 事件监听器未移除
- 窗口引用未释放

**解决方案**：
```typescript
// 1. 清理定时器
useEffect(() => {
  const timer = setTimeout(() => {}, 1000);
  return () => clearTimeout(timer);
}, []);

// 2. 清理事件监听器
useEffect(() => {
  const removeListener = window.electronAPI.onMenuAction(callback);
  return () => removeListener?.();
}, []);

// 3. 主进程清理窗口引用
floatingWindow.on("closed", () => {
  floatingWindows.delete(noteId);
  floatingWindow = null;  // 释放引用
});
```

---

### 5. 窗口位置和大小保存

**问题**：关闭悬浮窗口后，再次打开位置和大小不一致。

**解决方案**：
```javascript
// 1. 监听窗口位置和大小变化
floatingWindow.on("moved", () => {
  const bounds = floatingWindow.getBounds();
  // 保存位置到数据库或配置文件
  saveWindowPosition(noteId, bounds);
});

floatingWindow.on("resized", () => {
  const bounds = floatingWindow.getBounds();
  // 保存大小到数据库或配置文件
  saveWindowSize(noteId, bounds);
});

// 2. 创建窗口时恢复位置和大小
const savedBounds = loadWindowBounds(noteId);
const floatingWindow = new BrowserWindow({
  x: savedBounds?.x,
  y: savedBounds?.y,
  width: savedBounds?.width || 400,
  height: savedBounds?.height || 300,
  // ...
});
```

---

## 总结

### 核心要点

1. **架构设计**
   - 主进程管理窗口生命周期
   - Preload 脚本提供安全的 API
   - 渲染进程负责 UI 和交互

2. **窗口特性**
   - `frame: false` + `transparent: true` 实现无边框透明窗口
   - `-webkit-app-region: drag` 实现拖拽功能
   - `alwaysOnTop: true` 保持窗口置顶

3. **数据同步**
   - IPC 通信实现双向数据同步
   - 防抖优化减少通信频率
   - 事件监听器确保状态一致

4. **性能优化**
   - 延迟显示窗口 (`show: false`)
   - 及时清理资源（定时器、监听器、窗口引用）
   - 使用 Map 管理多个窗口实例

5. **用户体验**
   - 支持编辑标题和内容
   - 提供编辑工具栏
   - 优雅的加载和错误状态

### 适用场景

这个实现方案适用于：
- 需要悬浮显示内容的桌面应用
- 笔记、待办、提醒类应用
- 需要多窗口管理的场景
- 跨平台桌面应用开发

### 扩展建议

1. **增强功能**
   - 支持窗口吸附边缘
   - 支持透明度调节
   - 支持快捷键操作

2. **性能优化**
   - 虚拟化长列表内容
   - 图片懒加载
   - 节流窗口大小变化事件

3. **用户体验**
   - 添加窗口动画效果
   - 支持主题切换
   - 提供更多自定义选项

---

## 附录：完整文件清单

### 必需文件
1. `electron/main.cjs` - 主进程逻辑
2. `electron/preload.cjs` - Preload 脚本
3. `floating.html` - 悬浮窗口 HTML
4. `src/pages/FloatingNote.tsx` - 悬浮窗口 React 组件
5. `src/pages/FloatingNote.css` - 悬浮窗口样式
6. `src/components/notes/StickyNote.tsx` - 主窗口便签组件（触发悬浮）
7. `src/App.tsx` - 主应用（数据同步）
8. `src/types/electron.d.ts` - TypeScript 类型定义

### 配置文件
1. `package.json` - 依赖和构建脚本
2. `vite.config.ts` - Vite 配置（多入口）

---

**文档版本**: 1.0  
**最后更新**: 2025-10-12  
**作者**: Infinity Notes 开发团队  
**许可**: MIT License
