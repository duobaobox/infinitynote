# 思维链开发指南

## 概述

本文档详细介绍了 Infinity Notes 项目中思维链（ThinkingChain）功能的完整实现机制，包括思维链解析、折叠组件实现、以及步骤明确化的技术细节。

## 目录

1. [架构概览](#架构概览)
2. [思维链解析机制](#思维链解析机制)
3. [思维链数据结构](#思维链数据结构)
4. [折叠组件实现](#折叠组件实现)
5. [步骤明确化机制](#步骤明确化机制)
6. [样式系统](#样式系统)
7. [使用示例](#使用示例)
8. [开发指引](#开发指引)

## 架构概览

思维链功能采用分层架构设计：

```
┌─────────────────────────────────────────┐
│              用户界面层                    │
│  ┌─────────────────┐ ┌─────────────────┐  │
│  │  ThinkingChain  │ │   StickyNote    │  │
│  │     组件        │ │      组件       │  │
│  └─────────────────┘ └─────────────────┘  │
└─────────────────────────────────────────┘
┌─────────────────────────────────────────┐
│              数据处理层                    │
│  ┌─────────────────┐ ┌─────────────────┐  │
│  │   AI解析服务     │ │  内容格式服务    │  │
│  │   (AIService)   │ │(ContentFormat)  │  │
│  └─────────────────┘ └─────────────────┘  │
└─────────────────────────────────────────┘
┌─────────────────────────────────────────┐
│              数据存储层                    │
│  ┌─────────────────┐ ┌─────────────────┐  │
│  │   IndexedDB     │ │   类型定义      │  │
│  │    存储         │ │   (types.ts)    │  │
│  └─────────────────┘ └─────────────────┘  │
└─────────────────────────────────────────┘
```

## 思维链解析机制

### 1. XML标签格式解析

思维链解析器使用科学的XML标签格式，支持多种AI模型：

```typescript
// 支持的标签格式
const thinkingPatterns = [
  /<thinking>([\s\S]*?)<\/thinking>/gi, // 通用格式（GPT、Claude等）
  /<think>([\s\S]*?)<\/think>/gi,       // DeepSeek R1格式
];
```

### 2. 解析流程

```typescript
/**
 * 思维链解析流程
 * 位置: src/services/ai/aiService.ts:1074-1151
 */
private parseThinkingChain(
  response: string,
  originalPrompt: string,
  showThinkingMode: boolean = true
) {
  // 1. 使用正则表达式匹配XML标签
  for (const pattern of thinkingPatterns) {
    const match = response.match(pattern);
    if (match && match[1]) {
      thinkingContent = match[1].trim();
      cleanContent = response.replace(pattern, "").trim();
      foundThinking = true;
      break;
    }
  }

  // 2. 如果不显示思维模式，只返回干净内容
  if (!showThinkingMode) {
    return { cleanContent: cleanContent.trim() };
  }

  // 3. 解析思维链步骤
  const steps = this.parseThinkingStepsInternal(thinkingContent);

  // 4. 创建思维链对象
  const thinkingChain = {
    id: `thinking-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
    prompt: originalPrompt,
    steps,
    totalThinkingTime: steps.length * 1000,
    createdAt: new Date(),
  };

  return { thinkingChain, cleanContent };
}
```

### 3. 步骤解析算法

```typescript
/**
 * 思维步骤解析器
 * 位置: src/services/ai/aiService.ts:1158-1211
 */
private parseThinkingStepsInternal(thinkingContent: string) {
  // 按段落分割思考内容
  const paragraphs = thinkingContent
    .split(/\n\s*\n/)
    .map((p) => p.trim())
    .filter((p) => p.length > 0);

  // 步骤类型判断规则
  const stepTypeRules = [
    { keywords: ["分析", "观察", "数据", "检查"], type: "analysis" },
    { keywords: ["结论", "总结", "因此", "所以"], type: "conclusion" },
    { keywords: ["?", "？", "如何", "为什么", "是否"], type: "question" },
    { keywords: ["想法", "建议", "可以", "应该"], type: "idea" },
  ];

  return paragraphs.map((paragraph, index) => {
    // 智能匹配步骤类型
    let stepType = "reasoning"; // 默认类型
    for (const rule of stepTypeRules) {
      if (rule.keywords.some((keyword) => paragraph.includes(keyword))) {
        stepType = rule.type;
        break;
      }
    }

    return {
      id: `step-${Date.now()}-${index}-${Math.random().toString(36).substring(2, 8)}`,
      content: paragraph,
      stepType,
      timestamp: new Date(Date.now() + index * 100),
      order: index + 1,
    };
  });
}
```

## 思维链数据结构

### 1. 核心类型定义

```typescript
// 位置: src/components/types.ts:14-31
export interface ThinkingStep {
  id: string;                    // 步骤唯一标识
  content: string;               // 步骤内容
  stepType: "analysis" | "reasoning" | "conclusion" | "question" | "idea";
  timestamp: Date;               // 时间戳
  order: number;                 // 步骤顺序
}

export interface ThinkingChain {
  id: string;                    // 思维链唯一标识
  prompt: string;                // 原始提示词
  steps: ThinkingStep[];         // 思维步骤数组
  totalThinkingTime: number;     // 总思考时间（毫秒）
  createdAt: Date;              // 创建时间
}
```

### 2. 便签数据集成

```typescript
// 位置: src/components/types.ts:34-59
export interface StickyNote {
  // 基础属性
  id: string;
  content: JSONContent;          // TipTap JSON格式内容
  title: string;
  
  // 思维链相关
  thinkingChain?: ThinkingChain; // 思维链数据（可选）
  hasThinking?: boolean;         // 是否包含思维链
}
```

## 折叠组件实现

### 1. 组件结构

```typescript
// 位置: src/components/thinking/ThinkingChain.tsx:79-199
const ThinkingChain: React.FC<ThinkingChainProps> = ({
  thinkingChain,
  defaultExpanded = false,
  compact = false,
  inNote = false,
}) => {
  // 折叠状态管理
  const [isExpanded, setIsExpanded] = React.useState(defaultExpanded);

  // 切换展开/折叠状态
  const toggleExpanded = () => {
    setIsExpanded(!isExpanded);
  };

  return (
    <div className={`thinking-chain-container ${compact ? "compact" : ""} ${inNote ? "thinking-chain-in-note" : ""}`}>
      {/* 可点击的头部 */}
      <div className="thinking-header" onClick={toggleExpanded}>
        <div className="thinking-title">
          <ExperimentOutlined style={{ marginRight: 8, color: "#1890ff" }} />
          <Text strong>AI思考过程</Text>
          <Tag color="blue">{thinkingChain.steps.length}步</Tag>
          {!compact && (
            <Text type="secondary" className="thinking-time">
              {formatThinkingTime(thinkingChain.totalThinkingTime)}
            </Text>
          )}
        </div>
        <div className="thinking-expand-icon">{isExpanded ? "▼" : "▶"}</div>
      </div>

      {/* 条件渲染的内容区域 */}
      {isExpanded && !compact && renderThinkingStats()}
      {isExpanded && (
        <div className="thinking-process-section">{renderThinkingSteps()}</div>
      )}
    </div>
  );
};
```

### 2. 折叠状态管理

```typescript
// 状态定义
const [isExpanded, setIsExpanded] = React.useState(defaultExpanded);

// 切换函数
const toggleExpanded = () => {
  setIsExpanded(!isExpanded);
};

// 条件渲染
{isExpanded && (
  <div className="thinking-process-section">
    {renderThinkingSteps()}
  </div>
)}
```

### 3. 响应式设计

组件支持多种显示模式：

- **普通模式**: 完整显示，包含统计信息
- **紧凑模式**: 精简显示，适合小空间
- **便签内模式**: 特殊优化，适应便签尺寸

```typescript
// 模式控制
const className = `thinking-chain-container 
  ${compact ? "compact" : ""} 
  ${inNote ? "thinking-chain-in-note" : ""}`;
```

## 步骤明确化机制

### 1. 步骤类型系统

项目定义了5种思维步骤类型：

```typescript
type StepType = "analysis" | "reasoning" | "conclusion" | "question" | "idea";
```

### 2. 视觉标识系统

每种步骤类型都有独特的视觉标识：

```typescript
// 位置: src/components/thinking/ThinkingChain.tsx:28-43
const getStepIcon = (stepType: ThinkingStep["stepType"]) => {
  switch (stepType) {
    case "analysis":
      return { icon: <SearchOutlined />, color: "#1890ff" };      // 蓝色搜索图标
    case "reasoning": 
      return { icon: <ExperimentOutlined />, color: "#52c41a" };  // 绿色实验图标
    case "conclusion":
      return { icon: <TrophyOutlined />, color: "#fa8c16" };      // 橙色奖杯图标
    case "question":
      return { icon: <QuestionCircleOutlined />, color: "#eb2f96" }; // 粉色问号图标
    case "idea":
      return { icon: <BulbOutlined />, color: "#722ed1" };        // 紫色灯泡图标
    default:
      return { icon: <ExperimentOutlined />, color: "#52c41a" };
  }
};
```

### 3. 中文标签系统

```typescript
// 位置: src/components/thinking/ThinkingChain.tsx:46-61
const getStepTypeLabel = (stepType: ThinkingStep["stepType"]) => {
  switch (stepType) {
    case "analysis":   return "分析";
    case "reasoning":  return "推理";
    case "conclusion": return "结论";
    case "question":   return "疑问";
    case "idea":       return "想法";
    default:          return "思考";
  }
};
```

### 4. 步骤渲染

```typescript
// 位置: src/components/thinking/ThinkingChain.tsx:88-139
const renderThinkingSteps = () => {
  return (
    <div className="thinking-steps-list">
      {thinkingChain.steps.map((step) => {
        const { icon, color } = getStepIcon(step.stepType);

        return (
          <div key={step.id} className="thinking-step-item">
            {/* 步骤头部：图标标签 + 时间 */}
            <div className="thinking-step-header">
              <div className="thinking-step-tag-with-icon" style={{ color: color }}>
                <span style={{ color: color }}>{icon}</span>
                <span style={{ color: color }}>
                  {getStepTypeLabel(step.stepType)}
                </span>
              </div>
              <Text type="secondary" className="thinking-step-time">
                <ClockCircleOutlined style={{ marginRight: 4 }} />
                {formatTimestamp(step.timestamp)}
              </Text>
            </div>

            {/* 步骤内容 */}
            <div className="thinking-step-content">
              <Paragraph className="thinking-step-text">
                {step.content}
              </Paragraph>
            </div>
          </div>
        );
      })}
    </div>
  );
};
```

## 样式系统

### 1. CSS架构

样式文件采用BEM命名规范，结构清晰：

```css
/* 位置: src/components/thinking/ThinkingChain.css */

/* 主容器 */
.thinking-chain-container { }

/* 头部区域 */
.thinking-header { }
.thinking-title { }
.thinking-expand-icon { }

/* 内容区域 */
.thinking-process-section { }
.thinking-steps-list { }

/* 单个步骤 */
.thinking-step-item { }
.thinking-step-header { }
.thinking-step-content { }
.thinking-step-tag-with-icon { }
```

### 2. 响应式适配

```css
/* 紧凑模式 */
.thinking-chain-container.compact {
  margin-bottom: 12px;
  background: transparent;
  border: none;
}

/* 便签内模式 */
.thinking-chain-in-note {
  margin: 0;
  padding: 0;
}

/* 移动端适配 */
@media (max-width: 768px) {
  .thinking-stats {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .thinking-step-header {
    flex-direction: column;
    align-items: flex-start;
  }
}
```

### 3. 滚动容器优化

```css
.thinking-process-section {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: hidden;
  
  /* 滚动条样式 */
  scrollbar-width: thin;
  scrollbar-color: #d9d9d9 transparent;
}

/* Webkit浏览器滚动条 */
.thinking-process-section::-webkit-scrollbar {
  width: 6px;
}

.thinking-process-section::-webkit-scrollbar-thumb {
  background-color: #d9d9d9;
  border-radius: 3px;
}
```

## 使用示例

### 1. 基本使用

```typescript
import { ThinkingChain } from '../components/thinking';

// 在便签组件中使用
const StickyNote = ({ note }) => {
  return (
    <div className="note-container">
      {/* 便签内容 */}
      <BasicEditor content={note.content} />
      
      {/* 思维链组件 */}
      {note.thinkingChain && (
        <ThinkingChain
          thinkingChain={note.thinkingChain}
          defaultExpanded={false}
          compact={true}
          inNote={true}
        />
      )}
    </div>
  );
};
```

### 2. 演示组件

```typescript
// 位置: src/components/thinking/ThinkingChainDemo.tsx:12-133
const ThinkingChainDemo: React.FC = () => {
  const createSampleThinkingChain = (): ThinkingChainType => {
    return {
      id: `demo-thinking-${Date.now()}`,
      prompt: "请帮我分析一下如何提高工作效率",
      steps: [
        {
          id: "step-1",
          content: "首先，我需要分析当前工作效率低下的可能原因...",
          stepType: "analysis",
          timestamp: new Date(Date.now() - 5000),
          order: 1,
        },
        // ... 更多步骤
      ],
      totalThinkingTime: 5000,
      createdAt: new Date(),
    };
  };

  return (
    <div>
      {/* 普通模式 */}
      <ThinkingChain
        thinkingChain={sampleData}
        defaultExpanded={false}
        compact={false}
      />

      {/* 紧凑模式 */}
      <ThinkingChain
        thinkingChain={sampleData}
        defaultExpanded={true}
        compact={true}
      />
    </div>
  );
};
```

## 开发指引

### 1. 添加新的步骤类型

如果需要扩展步骤类型，按以下步骤操作：

1. **更新类型定义**:
```typescript
// src/components/types.ts
export interface ThinkingStep {
  stepType: "analysis" | "reasoning" | "conclusion" | "question" | "idea" | "新类型";
}
```

2. **添加视觉标识**:
```typescript
// src/components/thinking/ThinkingChain.tsx
const getStepIcon = (stepType: ThinkingStep["stepType"]) => {
  switch (stepType) {
    // ... 现有类型
    case "新类型":
      return { icon: <新图标 />, color: "#新颜色" };
  }
};
```

3. **添加中文标签**:
```typescript
const getStepTypeLabel = (stepType: ThinkingStep["stepType"]) => {
  switch (stepType) {
    // ... 现有类型
    case "新类型": return "新标签";
  }
};
```

4. **更新解析规则**:
```typescript
// src/services/ai/aiService.ts
const stepTypeRules = [
  // ... 现有规则
  { keywords: ["新关键词1", "新关键词2"], type: "新类型" },
];
```

### 2. 自定义样式

创建自定义样式主题：

```css
/* 自定义主题 */
.thinking-chain-container.custom-theme {
  --primary-color: #your-color;
  --background-color: #your-bg;
  --border-color: #your-border;
}

.thinking-chain-container.custom-theme .thinking-step-tag-with-icon {
  color: var(--primary-color);
}
```

### 3. 性能优化建议

1. **虚拟化长列表**: 对于步骤数量很多的思维链，考虑使用虚拟化
2. **懒加载内容**: 只在展开时渲染步骤内容
3. **缓存计算结果**: 缓存步骤统计等计算结果

```typescript
// 使用 useMemo 优化性能
const stepStats = useMemo(() => {
  return thinkingChain.steps.reduce((acc, step) => {
    acc[step.stepType] = (acc[step.stepType] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
}, [thinkingChain.steps]);
```

### 4. 测试建议

1. **单元测试**: 测试解析逻辑和步骤分类
2. **组件测试**: 测试折叠/展开功能
3. **集成测试**: 测试完整的思维链生成流程

```typescript
// 测试示例
describe('ThinkingChain', () => {
  it('应该正确解析思维链步骤', () => {
    const mockResponse = '<thinking>这是分析步骤</thinking>最终答案';
    const result = parseThinkingChain(mockResponse, '测试提示', true);
    
    expect(result.thinkingChain).toBeDefined();
    expect(result.thinkingChain.steps).toHaveLength(1);
    expect(result.thinkingChain.steps[0].stepType).toBe('analysis');
  });

  it('应该支持折叠/展开功能', () => {
    render(<ThinkingChain thinkingChain={mockData} />);
    
    const header = screen.getByText('AI思考过程');
    fireEvent.click(header);
    
    expect(screen.getByText('步骤内容')).toBeInTheDocument();
  });
});
```

## 总结

思维链功能是一个完整的端到端解决方案，包含：

1. **智能解析**: 使用XML标签格式解析AI回复中的思维过程
2. **结构化存储**: 将思维过程转换为结构化数据
3. **可视化展示**: 通过折叠组件优雅地展示思维过程
4. **步骤明确化**: 通过图标、颜色、标签系统明确区分不同类型的思维步骤
5. **响应式设计**: 适应不同尺寸和使用场景

这个系统的核心优势在于：
- **可扩展性**: 易于添加新的步骤类型和视觉样式
- **用户体验**: 折叠功能避免界面混乱，按需查看
- **智能化**: 自动识别和分类思维步骤
- **兼容性**: 支持多种AI模型的标准输出格式

通过这个文档，开发者可以快速理解和复刻思维链功能的完整实现。