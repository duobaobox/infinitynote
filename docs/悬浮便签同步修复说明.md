# 悬浮便签同步问题修复说明

## 📋 问题描述

### 问题 1：悬浮窗口大小同步到画布

**现象**：调整悬浮窗口大小时，画布中对应的便签也会同步调整大小
**影响**：用户无法为悬浮窗口设置独立的显示尺寸

### 问题 2：画布编辑不同步到悬浮窗口

**现象**：在画布中编辑便签的标题或内容时，已打开的悬浮窗口不会更新
**影响**：数据不一致，用户体验差

## ✅ 修复方案

### 修复 1：移除悬浮窗口大小同步

**修改的文件**：

1. `electron/main.cjs` - 移除窗口 resize 事件监听
2. `src/App.tsx` - 移除 floating-note-resized 事件处理

**具体改动**：

#### electron/main.cjs

```javascript
// ❌ 删除这段代码
floatingWindow.on("resize", () => {
  if (!floatingWindow.isDestroyed()) {
    const bounds = floatingWindow.getBounds();
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send("floating-note-resized", {
        noteId,
        width: bounds.width,
        height: bounds.height,
      });
    }
  }
});

// ✅ 添加注释说明
// 注意：悬浮窗口的大小调整不同步到画布便签
// 悬浮窗口和画布便签保持独立的尺寸
```

#### src/App.tsx

```typescript
// ❌ 删除这段代码
if (eventName === "floating-note-resized" && data?.noteId) {
  console.log("📐 悬浮便签大小变化:", data);
  const { noteId, width, height } = data;
  if (noteId && width && height) {
    updateNote(noteId, { size: { width, height } });
  }
}

// ✅ 添加注释说明
// 注意：悬浮窗口大小变化事件已移除，不再同步到画布
```

**效果**：

- ✅ 悬浮窗口可以独立设置显示尺寸
- ✅ 画布中的便签尺寸不受影响
- ✅ 两者互不干扰

---

### 修复 2：添加主窗口 → 悬浮窗口同步

**修改的文件**：

1. `src/store/noteStore.ts` - updateNote 函数中添加同步逻辑
2. `electron/main.cjs` - 优化 update-floating-note 处理器
3. `electron/preload.cjs` - 更新 API 签名
4. `src/types/electron.d.ts` - 更新类型定义

**具体改动**：

#### 1. src/store/noteStore.ts

```typescript
// 在 updateNote 函数中添加
// 同步到悬浮窗口（如果存在）
if (window.electronAPI?.floating?.updateFloatingNote) {
  // 传递 fromMainWindow=true 参数，避免循环更新
  window.electronAPI.floating
    .updateFloatingNote(id, updatesWithTime, true)
    .catch(() => {
      // 静默失败，可能悬浮窗口不存在
    });
}
```

#### 2. electron/main.cjs

```javascript
// 添加 fromMainWindow 参数，避免循环更新
ipcMain.handle(
  "update-floating-note",
  (event, noteId, updates, fromMainWindow = false) => {
    try {
      const window = floatingWindows.get(noteId);

      // 更新悬浮窗口
      if (window && !window.isDestroyed()) {
        window.webContents.send("note-data-updated", { noteId, ...updates });
      }

      // 只有当更新来自悬浮窗口时，才通知主窗口
      // 避免循环更新
      if (!fromMainWindow && mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send("floating-note-updated", {
          noteId,
          updates,
        });
      }

      return { success: true };
    } catch (error) {
      console.error("更新悬浮便签失败:", error);
      return { success: false, error: error.message };
    }
  }
);
```

#### 3. electron/preload.cjs

```javascript
updateFloatingNote: (noteId, updates, fromMainWindow) =>
  ipcRenderer.invoke("update-floating-note", noteId, updates, fromMainWindow),
```

#### 4. src/types/electron.d.ts

```typescript
updateFloatingNote: (
  noteId: string,
  updates: Record<string, any>,
  fromMainWindow?: boolean // 新增参数
) => Promise<{ success: boolean; error?: string }>;
```

**效果**：

- ✅ 在画布编辑便签时，悬浮窗口实时更新
- ✅ 在悬浮窗口编辑时，画布便签实时更新
- ✅ 避免了循环更新问题
- ✅ 双向同步完美工作

---

## 🔄 数据同步流程

### 场景 1：在悬浮窗口编辑

```
用户在悬浮窗口编辑
    ↓
FloatingNote 组件调用 updateFloatingNote(noteId, updates)
    ↓ fromMainWindow = undefined (默认 false)
主进程 update-floating-note
    ↓
1. 更新悬浮窗口（自己，可能无效但无害）
2. 通知主窗口 → floating-note-updated
    ↓
主窗口 App.tsx 监听事件
    ↓
调用 noteStore.updateNote()
    ↓
更新数据库和内存
    ↓
尝试通知悬浮窗口（fromMainWindow=true）
    ↓
主进程收到请求，但 fromMainWindow=true
    ↓
只更新悬浮窗口，不再通知主窗口 ✅ 避免循环
```

### 场景 2：在画布编辑

```
用户在画布编辑便签
    ↓
调用 noteStore.updateNote()
    ↓
1. 更新数据库和内存
2. 调用 updateFloatingNote(noteId, updates, true)
    ↓ fromMainWindow = true
主进程 update-floating-note
    ↓
1. 更新悬浮窗口 ✅
2. fromMainWindow=true，不通知主窗口 ✅ 避免循环
    ↓
悬浮窗口接收 note-data-updated 事件
    ↓
FloatingNote 组件更新本地状态
    ↓
UI 刷新显示新内容 ✅
```

---

## 🧪 测试验证

### 测试 1：悬浮窗口独立大小

**步骤**：

1. 创建一个便签并悬浮
2. 调整悬浮窗口大小
3. 检查画布中的便签大小

**预期结果**：

- ✅ 悬浮窗口可以自由调整大小
- ✅ 画布便签大小保持不变
- ✅ 两者尺寸独立

### 测试 2：画布 → 悬浮窗口同步

**步骤**：

1. 创建一个便签并悬浮
2. 在画布中编辑便签标题
3. 观察悬浮窗口

**预期结果**：

- ✅ 悬浮窗口标题立即更新
- ✅ 无延迟
- ✅ 内容一致

### 测试 3：画布 → 悬浮窗口同步（内容）

**步骤**：

1. 创建一个便签并悬浮
2. 在画布中编辑便签内容
3. 观察悬浮窗口

**预期结果**：

- ✅ 悬浮窗口内容立即更新
- ✅ 富文本格式保持
- ✅ 无循环更新

### 测试 4：悬浮窗口 → 画布同步（验证未破坏）

**步骤**：

1. 创建一个便签并悬浮
2. 在悬浮窗口中编辑内容
3. 观察画布便签

**预期结果**：

- ✅ 画布便签立即更新
- ✅ 双向同步正常
- ✅ 无循环更新

### 测试 5：多窗口同步

**步骤**：

1. 创建多个便签并全部悬浮
2. 在画布编辑不同便签
3. 观察对应的悬浮窗口

**预期结果**：

- ✅ 每个悬浮窗口只更新对应的便签
- ✅ 不会误更新其他窗口
- ✅ 多窗口互不干扰

---

## 📊 修改文件清单

### 已修改的文件：

1. ✅ `electron/main.cjs` - 移除大小同步，优化更新逻辑
2. ✅ `electron/preload.cjs` - 更新 API 签名
3. ✅ `src/App.tsx` - 移除大小同步处理
4. ✅ `src/store/noteStore.ts` - 添加主窗口 → 悬浮窗口同步
5. ✅ `src/types/electron.d.ts` - 更新类型定义

### 未修改的文件：

- `src/pages/FloatingNote/index.tsx` - 已有正确的更新处理逻辑
- 其他组件 - 无需修改

---

## 🎯 关键改进点

### 1. 避免循环更新

通过 `fromMainWindow` 参数区分更新来源：

- 来自悬浮窗口：需要通知主窗口
- 来自主窗口：只更新悬浮窗口，不回传

### 2. 独立的窗口尺寸

- 悬浮窗口尺寸：用户可自由调整，适应不同场景
- 画布便签尺寸：保持原有设计，不受影响

### 3. 完整的双向同步

- 悬浮窗口 → 画布：实时同步标题和内容
- 画布 → 悬浮窗口：实时同步标题和内容
- 双向同步，数据一致

### 4. 错误处理

- 静默失败：悬浮窗口不存在时不报错
- 优雅降级：Electron API 不可用时跳过同步

---

## 🚀 后续优化建议

### 可选优化项：

1. **窗口位置记忆** - 记住每个悬浮窗口的位置
2. **性能优化** - 节流更新频率（如正在快速输入时）
3. **冲突检测** - 检测同时编辑冲突
4. **离线同步** - 断网后的数据同步策略

### 当前状态：

- ✅ 基础功能完整
- ✅ 双向同步正常
- ✅ 无循环更新
- ✅ 数据一致性保证

---

**修复版本**: 2.0.1  
**修复日期**: 2025-10-12  
**修复人员**: GitHub Copilot
