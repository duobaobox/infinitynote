<!DOCTYPE html>
<html>
<head>
    <title>测试流式累积问题</title>
</head>
<body>
    <h1>流式累积问题测试</h1>
    <div id="output"></div>
    
    <script>
        // 模拟AI服务的流式处理逻辑
        class MockStreamingMarkdownBuffer {
            constructor() {
                this.buffer = "";
                this.lastCompleteContent = "";
            }
            
            addChunk(chunk) {
                console.log("接收到chunk:", chunk);
                this.buffer += chunk;
                console.log("当前buffer:", this.buffer);
                
                // 检查是否有完整的语法结构
                const completeContent = this.buffer; // 简化版本
                
                if (completeContent !== this.lastCompleteContent) {
                    const isIncremental = this.lastCompleteContent.length > 0;
                    this.lastCompleteContent = completeContent;
                    
                    return {
                        shouldConvert: true,
                        content: completeContent,
                        isIncremental,
                    };
                }
                
                return {
                    shouldConvert: false,
                    content: this.buffer,
                    isIncremental: false,
                };
            }
            
            reset() {
                this.buffer = "";
                this.lastCompleteContent = "";
            }
        }
        
        // 模拟AI服务的处理逻辑
        function simulateAIService() {
            const buffer = new MockStreamingMarkdownBuffer();
            let fullMarkdown = "";
            
            // 模拟AI返回的增量内容
            const chunks = ["好的", "，我们来", "详细", "解释", "一下"];
            
            console.log("=== 模拟AI服务处理逻辑 ===");
            
            chunks.forEach((deltaContent, index) => {
                console.log(`\n--- 第${index + 1}次处理 ---`);
                console.log("AI返回的增量内容:", deltaContent);
                
                // AI服务层：累积内容
                fullMarkdown += deltaContent;
                console.log("AI服务累积的完整内容:", fullMarkdown);
                
                // 调用convertStreamChunk（传入完整内容）
                const result = buffer.addChunk(fullMarkdown); // 这里是问题所在！
                console.log("转换器返回:", result);
                
                document.getElementById('output').innerHTML += 
                    `<p>第${index + 1}次: ${result.content}</p>`;
            });
        }
        
        // 正确的处理逻辑
        function correctAIService() {
            const buffer = new MockStreamingMarkdownBuffer();
            let fullMarkdown = "";
            
            // 模拟AI返回的增量内容
            const chunks = ["好的", "，我们来", "详细", "解释", "一下"];
            
            console.log("\n=== 正确的处理逻辑 ===");
            buffer.reset();
            
            chunks.forEach((deltaContent, index) => {
                console.log(`\n--- 第${index + 1}次处理（正确版本）---`);
                console.log("AI返回的增量内容:", deltaContent);
                
                // 直接传递增量内容给转换器
                const result = buffer.addChunk(deltaContent); // 正确做法
                console.log("转换器返回:", result);
                
                document.getElementById('output').innerHTML += 
                    `<p>正确第${index + 1}次: ${result.content}</p>`;
            });
        }
        
        // 运行测试
        setTimeout(() => {
            simulateAIService();
            setTimeout(() => {
                correctAIService();
            }, 2000);
        }, 1000);
    </script>
</body>
</html>
