/**
 * æ€ç»´é“¾æ˜¾ç¤ºç»„ä»¶
 * ç”¨äºåœ¨ TipTap ç¼–è¾‘å™¨ä¸­æ˜¾ç¤º AI çš„æ€ç»´è¿‡ç¨‹
 */

import { memo } from "react";
import { Button, Steps } from "antd";
import { EyeOutlined, EyeInvisibleOutlined } from "@ant-design/icons";
import type { AICustomProperties } from "../../types/ai";
import styles from "./ThinkingChainDisplay.module.css";

const { Text } = Typography;

// æ­¥éª¤ç±»å‹å®šä¹‰
type StepType = "analysis" | "reasoning" | "conclusion" | "question" | "idea";

interface ThinkingChainDisplayProps {
  /** æ€ç»´é“¾æ•°æ® */
  thinkingData: NonNullable<AICustomProperties["ai"]>["thinkingChain"];
  /** æ˜¯å¦æŠ˜å  */
  isCollapsed: boolean;
  /** åˆ‡æ¢æŠ˜å çŠ¶æ€å›è°ƒ */
  onToggle: () => void;
}

/**
 * è·å–æ­¥éª¤ç±»å‹å›¾æ ‡å’Œé¢œè‰²
 */
const getStepIcon = (stepType: StepType) => {
  switch (stepType) {
    case "analysis":
      return { icon: <SearchOutlined />, color: "#1890ff" }; // è“è‰²æœç´¢å›¾æ ‡
    case "reasoning":
      return { icon: <ExperimentOutlined />, color: "#52c41a" }; // ç»¿è‰²å®éªŒå›¾æ ‡
    case "conclusion":
      return { icon: <TrophyOutlined />, color: "#fa8c16" }; // æ©™è‰²å¥–æ¯å›¾æ ‡
    case "question":
      return { icon: <QuestionCircleOutlined />, color: "#eb2f96" }; // ç²‰è‰²é—®å·å›¾æ ‡
    case "idea":
      return { icon: <BulbOutlined />, color: "#722ed1" }; // ç´«è‰²ç¯æ³¡å›¾æ ‡
    default:
      return { icon: <ExperimentOutlined />, color: "#52c41a" };
  }
};

/**
 * è·å–æ­¥éª¤ç±»å‹ä¸­æ–‡æ ‡ç­¾
 */
const getStepTypeLabel = (stepType: StepType) => {
  switch (stepType) {
    case "analysis":
      return "åˆ†æ";
    case "reasoning":
      return "æ¨ç†";
    case "conclusion":
      return "ç»“è®º";
    case "question":
      return "ç–‘é—®";
    case "idea":
      return "æƒ³æ³•";
    default:
      return "æ€è€ƒ";
  }
};

/**
 * æ™ºèƒ½æ£€æµ‹æ­¥éª¤ç±»å‹
 */
const detectStepType = (content: string): StepType => {
  const stepTypeRules = [
    {
      keywords: ["åˆ†æ", "è§‚å¯Ÿ", "æ•°æ®", "æ£€æŸ¥", "ç ”ç©¶", "è°ƒæŸ¥"],
      type: "analysis" as StepType,
    },
    {
      keywords: ["ç»“è®º", "æ€»ç»“", "å› æ­¤", "æ‰€ä»¥", "ç»¼ä¸Š", "æœ€ç»ˆ"],
      type: "conclusion" as StepType,
    },
    {
      keywords: ["?", "ï¼Ÿ", "å¦‚ä½•", "ä¸ºä»€ä¹ˆ", "æ˜¯å¦", "æ€ä¹ˆ", "ç–‘é—®"],
      type: "question" as StepType,
    },
    {
      keywords: ["æƒ³æ³•", "å»ºè®®", "å¯ä»¥", "åº”è¯¥", "æˆ–è®¸", "ä¸å¦¨", "å»ºè®®"],
      type: "idea" as StepType,
    },
  ];

  // æ™ºèƒ½åŒ¹é…æ­¥éª¤ç±»å‹
  for (const rule of stepTypeRules) {
    if (rule.keywords.some((keyword) => content.includes(keyword))) {
      return rule.type;
    }
  }

  return "reasoning"; // é»˜è®¤ç±»å‹
};

/**
 * æ€ç»´é“¾æ˜¾ç¤ºç»„ä»¶
 */
export const ThinkingChainDisplay = memo<ThinkingChainDisplayProps>(
  ({ thinkingData, isCollapsed, onToggle }) => {
    console.log("ğŸ§  ThinkingChainDisplay æ¸²æŸ“:", {
      hasThinkingData: !!thinkingData,
      stepsLength: thinkingData?.steps?.length || 0,
      totalSteps: thinkingData?.totalSteps || 0,
      summary: thinkingData?.summary,
      isCollapsed,
      // å¢åŠ æ›´è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
      thinkingDataStructure: thinkingData
        ? {
            hasSteps: !!thinkingData.steps,
            stepsIsArray: Array.isArray(thinkingData.steps),
            firstStepId: thinkingData.steps?.[0]?.id,
            firstStepContent: thinkingData.steps?.[0]?.content?.substring(
              0,
              30
            ),
          }
        : null,
    });

    // æ›´ä¸¥æ ¼çš„æ•°æ®éªŒè¯ï¼Œä½†å…è®¸éƒ¨åˆ†æ•°æ®ç¼ºå¤±
    if (!thinkingData) {
      console.log("âš ï¸ ThinkingChainDisplay: thinkingData ä¸ºç©ºï¼Œä¸æ˜¾ç¤º");
      return null;
    }

    if (!thinkingData.steps || !Array.isArray(thinkingData.steps)) {
      console.log("âš ï¸ ThinkingChainDisplay: steps ä¸æ˜¯æœ‰æ•ˆæ•°ç»„ï¼Œä¸æ˜¾ç¤º");
      return null;
    }

    if (thinkingData.steps.length === 0) {
      console.log("âš ï¸ ThinkingChainDisplay: steps æ•°ç»„ä¸ºç©ºï¼Œä¸æ˜¾ç¤º");
      return null;
    }

    // éªŒè¯ steps æ•°æ®çš„åŸºæœ¬ç»“æ„
    const validSteps = thinkingData.steps.filter(
      (step) =>
        step && step.id && step.content && typeof step.timestamp === "number"
    );

    if (validSteps.length === 0) {
      console.log("âš ï¸ ThinkingChainDisplay: æ²¡æœ‰æœ‰æ•ˆçš„ step æ•°æ®ï¼Œä¸æ˜¾ç¤º");
      return null;
    }

    if (validSteps.length !== thinkingData.steps.length) {
      console.warn(
        `âš ï¸ ThinkingChainDisplay: å‘ç° ${
          thinkingData.steps.length - validSteps.length
        } ä¸ªæ— æ•ˆæ­¥éª¤ï¼Œå·²è¿‡æ»¤`
      );
    }

    const formatTime = (timestamp: number) => {
      return new Date(timestamp).toLocaleTimeString("zh-CN", {
        hour12: false,
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
      });
    };

    // å°†éªŒè¯è¿‡çš„æ€ç»´é“¾æ­¥éª¤è½¬æ¢ä¸ºå¸¦ç±»å‹çš„ Steps ç»„ä»¶æ ¼å¼
    const stepsItems = validSteps.map((step, index) => {
      const stepType = detectStepType(step.content);
      const { icon, color } = getStepIcon(stepType);

      return {
        title: (
          <div className={styles.stepTitle}>
            <div className={styles.stepTypeTag} style={{ color }}>
              {icon}
              <span className={styles.stepTypeLabel}>
                {getStepTypeLabel(stepType)}
              </span>
            </div>
            <Text type="secondary" className={styles.stepNumber}>
              ç¬¬ {index + 1} æ­¥
            </Text>
          </div>
        ),
        description: (
          <div className={styles.stepDescription}>
            <Text type="secondary" className={styles.stepTime}>
              <ClockCircleOutlined />
              {formatTime(step.timestamp)}
            </Text>
            <div className={styles.stepContent}>{step.content}</div>
          </div>
        ),
      };
    });

    // ç»Ÿè®¡ä¸åŒç±»å‹æ­¥éª¤æ•°é‡ï¼ˆä½¿ç”¨éªŒè¯è¿‡çš„æ­¥éª¤ï¼‰
    const stepStats = validSteps.reduce((acc, step) => {
      const stepType = detectStepType(step.content);
      acc[stepType] = (acc[stepType] || 0) + 1;
      return acc;
    }, {} as Record<StepType, number>);

    // ä½¿ç”¨å®é™…çš„æœ‰æ•ˆæ­¥éª¤æ•°é‡
    const actualTotalSteps = validSteps.length;

    return (
      <div className={styles.thinkingChainContainer}>
        {/* æ€ç»´é“¾å¤´éƒ¨ - å¢å¼ºç‰ˆè®¾è®¡ */}
        <div className={styles.thinkingHeader}>
          <div className={styles.thinkingHeaderLeft}>
            <ExperimentOutlined className={styles.thinkingIcon} />
            <span className={styles.thinkingTitle}>AI æ€ç»´è¿‡ç¨‹</span>
            <Tag color="blue" className={styles.stepCount}>
              {actualTotalSteps} æ­¥
            </Tag>
            {/* æ˜¾ç¤ºæ­¥éª¤ç±»å‹ç»Ÿè®¡ */}
            <div className={styles.stepStats}>
              {Object.entries(stepStats).map(([type, count]) => {
                const { color } = getStepIcon(type as StepType);
                return (
                  <span
                    key={type}
                    className={styles.statItem}
                    style={{ color }}
                  >
                    {getStepTypeLabel(type as StepType)}: {count}
                  </span>
                );
              })}
            </div>
          </div>
          <Button
            type="text"
            size="small"
            icon={isCollapsed ? <EyeOutlined /> : <EyeInvisibleOutlined />}
            onClick={onToggle}
            className={styles.toggleButton}
            title={isCollapsed ? "å±•å¼€æ€ç»´è¿‡ç¨‹" : "æŠ˜å æ€ç»´è¿‡ç¨‹"}
          />
        </div>

        {/* æ€ç»´é“¾å†…å®¹ - ä½¿ç”¨å¢å¼ºçš„ Steps ç»„ä»¶ */}
        {!isCollapsed && (
          <div className={styles.thinkingContent}>
            <div className={styles.stepsContainer}>
              <Steps
                direction="vertical"
                size="small"
                current={stepsItems.length}
                items={stepsItems}
                className={styles.thinkingSteps}
              />
            </div>

            {/* æ€ç»´é“¾æ€»ç»“ - æ›´ä¸°å¯Œçš„æ˜¾ç¤º */}
            {thinkingData.summary && (
              <div className={styles.thinkingSummary}>
                <BulbOutlined className={styles.summaryIcon} />
                <Text type="secondary" className={styles.summaryText}>
                  {thinkingData.summary}
                </Text>
              </div>
            )}
          </div>
        )}
      </div>
    );
  }
);

ThinkingChainDisplay.displayName = "ThinkingChainDisplay";

export default ThinkingChainDisplay;
